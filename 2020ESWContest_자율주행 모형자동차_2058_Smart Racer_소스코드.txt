-------------------------------------------main.c--------------------------------------------- 

#include <signal.h>
#include <pthread.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <termios.h>
#include <sys/time.h>
#include <errno.h>
#include <syslog.h>
#include "util.h"
#include "car_lib.h"

#include "display-kms.h"
#include "v4l2.h"
#include "vpe-common.h"
#include "drawing.h"
#include "input_cmd.h"
#include "exam_cv.h"
#include "jpeg_utils.h"

#define CAPTURE_IMG_W       1280
#define CAPTURE_IMG_H       720
#define CAPTURE_IMG_SIZE    (CAPTURE_IMG_W*CAPTURE_IMG_H*2) // YUYU : 16bpp
#define CAPTURE_IMG_FORMAT  "uyvy"

#define VPE_OUTPUT_W        640
#define VPE_OUTPUT_H        360

// Perspective Image Size
#define PERSPECTIVE_IMG_W 400
#define PERSPECTIVE_IMG_H 450

// display output & dump  format: NV12, w:320, h:180
//#define VPE_OUTPUT_IMG_SIZE    (VPE_OUTPUT_W*VPE_OUTPUT_H*3/2) // NV12 : 12bpp
//#define VPE_OUTPUT_FORMAT       "nv12"

// display output & dump  format: yuyv, w:320, h:180
//#define VPE_OUTPUT_IMG_SIZE    (VPE_OUTPUT_W*VPE_OUTPUT_H*2)
//#define VPE_OUTPUT_FORMAT       "yuyv"

#define VPE_OUTPUT_IMG_SIZE    (VPE_OUTPUT_W*VPE_OUTPUT_H*3)
#define VPE_OUTPUT_FORMAT       "bgr24"

#define PERSPEVTIVE_IMG_SIZE    (PERSPECTIVE_IMG_W*PERSPECTIVE_IMG_H*3)

#define OVERLAY_DISP_FORCC      FOURCC('A','R','2','4')
#define OVERLAY_DISP_W          480//480
#define OVERLAY_DISP_H          272//272

#define TIME_TEXT_X             385 //320
#define TIME_TEXT_Y             260 //240
#define TIME_TEXT_COLOR         0xffffffff //while

#define DUMP_MSGQ_KEY           1020
#define DUMP_MSGQ_MSG_TYPE      0x02

typedef enum {
    DUMP_NONE,
    DUMP_CMD,
    DUMP_READY,
    DUMP_WRITE_TO_FILE,
    DUMP_WRITE_TO_FILE_JPG,
    DUMP_DONE
}DumpState;

typedef struct _DumpMsg{
    long type;
    int  state_msg;
}DumpMsg;

struct thr_data {
    struct display *disp;
    struct v4l2 *v4l2;
    struct vpe *vpe;
    struct buffer **input_bufs;

    DumpState dump_state;
    unsigned char dump_img_data[VPE_OUTPUT_IMG_SIZE];
    int msgq_id;
    bool bfull_screen;
    bool bstream_start;
    pthread_t threads[6];
};


unsigned char dump_img_data_perspective[PERSPEVTIVE_IMG_SIZE];
unsigned char lanebuf[VPE_OUTPUT_W*VPE_OUTPUT_H];
unsigned char lanedistancebuf[PERSPECTIVE_IMG_W *PERSPECTIVE_IMG_H];

float infared_sensor_distance[7];
float Car_Yaw_Angle_data[2];
extern cRect ROI_Lane_Center_Check[3];
float lane_position[3][2];

static void VisionInit(void)
{
    printf("Vision Initialization !! ");
}
/**
  * @brief  Alloc vpe input buffer and a new buffer object
  * @param  data: pointer to parameter of thr_data
  * @retval none
  */ 
static int allocate_input_buffers(struct thr_data *data)
{
    int i;
    struct vpe *vpe = data->vpe;

    data->input_bufs = calloc(NUMBUF, sizeof(*data->input_bufs));
    for(i = 0; i < NUMBUF; i++) {
        data->input_bufs[i] = alloc_buffer(vpe->disp, vpe->src.fourcc, vpe->src.width, vpe->src.height, false);
    }
    if (!data->input_bufs)
        ERROR("allocating shared buffer failed\n");

    for (i = 0; i < NUMBUF; i++) {
        /** Get DMABUF fd for corresponding buffer object */
        vpe->input_buf_dmafd[i] = omap_bo_dmabuf(data->input_bufs[i]->bo[0]);
        data->input_bufs[i]->fd[0] = vpe->input_buf_dmafd[i];
    }
    return 0;
}

/**
  * @brief  Free vpe input buffer and destroy a buffer object
  * @param  buffer: pointer to parameter of buffer object
                  n : count of buffer object
                  bmultiplanar : multipanar value of buffer object
  * @retval none
  */
static void free_input_buffers(struct buffer **buffer, uint32_t n, bool bmultiplanar)
{
    uint32_t i;
    for (i = 0; i < n; i++) {
        if (buffer[i]) {
            close(buffer[i]->fd[0]);
            omap_bo_del(buffer[i]->bo[0]);
            if(bmultiplanar){
                close(buffer[i]->fd[1]);
                omap_bo_del(buffer[i]->bo[1]);
            }
        }
    }
    free(buffer);
}

/**
  * @brief  Draw operating time to overlay buffer.
  * @param  disp: pointer to parameter of struct display
                  time : operate time (ms)
  * @retval none
  */
static void draw_operatingtime(struct display *disp, uint32_t time)
{
    FrameBuffer tmpFrame;
    unsigned char* pbuf[4];
    char strtime[128];

    memset(strtime, 0, sizeof(strtime));

    sprintf(strtime, "%03d(ms)", time);

    if(get_framebuf(disp->overlay_p_bo, pbuf) == 0) {
        tmpFrame.buf = pbuf[0];
        tmpFrame.format = draw_get_pixel_foramt(disp->overlay_p_bo->fourcc);//FORMAT_RGB888; //alloc_overlay_plane() -- FOURCC('R','G','2','4');
        tmpFrame.stride = disp->overlay_p_bo->pitches[0];//tmpFrame.width*3;

        drawString(&tmpFrame, strtime, TIME_TEXT_X, TIME_TEXT_Y, 0, TIME_TEXT_COLOR);
    }
}

/**
  * @brief  Handle houht transform with opencv api
  * @param  disp: pointer to parameter of struct display
                 cambuf: vpe output buffer that converted capture image
  * @retval none
  */
 
static void lane_detection(struct display *disp, struct buffer *cambuf)
{
    unsigned char srcbuf[VPE_OUTPUT_W*VPE_OUTPUT_H*3];

    uint32_t optime;
    struct timeval st, et;
    unsigned char* cam_pbuf[4];
      if(get_framebuf(cambuf, cam_pbuf) == 0)
      {
        memcpy(srcbuf, cam_pbuf[0], VPE_OUTPUT_W*VPE_OUTPUT_H*3);

        gettimeofday(&st, NULL);
  
        OPenCV_Draw_ROI(srcbuf, VPE_OUTPUT_W, VPE_OUTPUT_H, cam_pbuf[0], VPE_OUTPUT_W, VPE_OUTPUT_H);
        OpenCV_Perspective_Calibration(srcbuf,VPE_OUTPUT_W, VPE_OUTPUT_H, dump_img_data_perspective);
        OpenCV_Lane_Detection(srcbuf,VPE_OUTPUT_W, VPE_OUTPUT_H, lanebuf);  //lanebuf[VPE_OUTPUT_W*VPE_OUTPUT_H];
        OpenCV_Land_Calilbration_Result(lanebuf, VPE_OUTPUT_W, VPE_OUTPUT_H, lanedistancebuf);
        OpenCV_Lane_YawAngle_Calculation(lanedistancebuf, PERSPECTIVE_IMG_W,PERSPECTIVE_IMG_H)  ;   
        gettimeofday(&et, NULL);
        optime = ((et.tv_sec - st.tv_sec)*1000)+ ((int)et.tv_usec/1000 - (int)st.tv_usec/1000);
        draw_operatingtime(disp, optime);
    }
}


static void hough_transform(struct display *disp, struct buffer *cambuf)
{
    unsigned char srcbuf[VPE_OUTPUT_W*VPE_OUTPUT_H*3];
    uint32_t optime;
    struct timeval st, et;

    unsigned char* cam_pbuf[4];
    if(get_framebuf(cambuf, cam_pbuf) == 0) {
        memcpy(srcbuf, cam_pbuf[0], VPE_OUTPUT_W*VPE_OUTPUT_H*3);

        gettimeofday(&st, NULL);

        OpenCV_hough_transform(srcbuf, VPE_OUTPUT_W, VPE_OUTPUT_H, cam_pbuf[0], VPE_OUTPUT_W, VPE_OUTPUT_H);

        gettimeofday(&et, NULL);
        optime = ((et.tv_sec - st.tv_sec)*1000)+ ((int)et.tv_usec/1000 - (int)st.tv_usec/1000);
        draw_operatingtime(disp, optime);
    }
}
/**
  * @brief  Save dump image data to jpeg file.
  * @param  buf: pointer to parameter of dump image data
                  w : image width
                  h : image height
  * @retval none
  */
static void cv_savetojpeg(unsigned char* buf, int w, int h)
{
    struct timeval timestamp;
    struct tm *today;
    char jpgname[256];

    gettimeofday(&timestamp, NULL);
    today = localtime(&timestamp.tv_sec);
    sprintf(jpgname, "%04d%02d%02d_%02d%02d%02d.jpg", today->tm_year+1900, today->tm_mon+1, today->tm_mday, today->tm_hour, today->tm_min, today->tm_sec);

   // OpenCV_Bgr2RgbConvert(buf, w, h, buf);
   //compress_rgb24_to_jpeg(buf, w, h, 80, jpgname);
}
/**
  * @brief  Camera capture, capture image covert by VPE and display after sobel edge
  * @param  arg: pointer to parameter of thr_data
  * @retval none
  */
void * capture_thread(void *arg)
{
    struct thr_data *data = (struct thr_data *)arg;
    struct v4l2 *v4l2 = data->v4l2;
    struct vpe *vpe = data->vpe;
    struct buffer *capt;
    bool isFirst = true;
    int index;
    //int count = 0;
    int i;

    v4l2_reqbufs(v4l2, NUMBUF);

    // init vpe input
    vpe_input_init(vpe);

    // allocate vpe input buffer
    allocate_input_buffers(data);

    if(vpe->dst.coplanar)
        vpe->disp->multiplanar = true;
    else
        vpe->disp->multiplanar = false;
    printf("disp multiplanar:%d \n", vpe->disp->multiplanar);

    // init /allocate vpe output
    vpe_output_init(vpe);
    vpe_output_fullscreen(vpe, data->bfull_screen);

    for (i = 0; i < NUMBUF; i++)
        v4l2_qbuf(v4l2,vpe->input_buf_dmafd[i], i);

    for (i = 0; i < NUMBUF; i++)
        vpe_output_qbuf(vpe, i);

    v4l2_streamon(v4l2);
    vpe_stream_on(vpe->fd, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);

    vpe->field = V4L2_FIELD_ANY;

    while(1) {
        index = v4l2_dqbuf(v4l2, &vpe->field);
        vpe_input_qbuf(vpe, index);

        if (isFirst) {
            vpe_stream_on(vpe->fd, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
            isFirst = false;
            MSG("streaming started...");
            data->bstream_start = true;
        }

        index = vpe_output_dqbuf(vpe);
        capt = vpe->disp_bufs[index];

        //hough_transform(vpe->disp, capt);
       
        lane_detection(vpe->disp,capt);
        Car_Yaw_Angle_Control();
        if (disp_post_vid_buffer(vpe->disp, capt, 0, 0, vpe->dst.width, vpe->dst.height)) {
            ERROR("Post buffer failed");
            return NULL;
        }
          update_overlay_disp(vpe->disp);

        if(data->dump_state == DUMP_READY)
        {
            DumpMsg dumpmsg;
            unsigned char* pbuf[4];

            if(get_framebuf(capt, pbuf) == 0)
            {
                switch(capt->fourcc) {
                    case FOURCC('Y','U','Y','V'):
                    case FOURCC('B','G','R','3'):
                        memcpy(data->dump_img_data, pbuf[0], VPE_OUTPUT_IMG_SIZE);
                       // memcpy(data->dump_img_data_perspective, pbuf[0], VPE_OUTPUT_IMG_SIZE);
                        break;
                    case FOURCC('N','V','1','2'):
                        memcpy(data->dump_img_data, pbuf[0], VPE_OUTPUT_W*VPE_OUTPUT_H); // y data
                        memcpy(data->dump_img_data+VPE_OUTPUT_W*VPE_OUTPUT_H, pbuf[1], VPE_OUTPUT_W*VPE_OUTPUT_H/2); // uv data
                        break;
                    default :
                        MSG("DUMP.. not yet support format : %.4s\n", (char*)&capt->fourcc);
                        break;
                }
            } else {
                MSG("dump capture buf fail !");
            }

            dumpmsg.type = DUMP_MSGQ_MSG_TYPE;
            dumpmsg.state_msg = DUMP_WRITE_TO_FILE;
            data->dump_state = DUMP_WRITE_TO_FILE;
            if (-1 == msgsnd(data->msgq_id, &dumpmsg, sizeof(DumpMsg)-sizeof(long), 0)) {
                MSG("state:%d, msg send fail\n", dumpmsg.state_msg);
            }
        }

        vpe_output_qbuf(vpe, index);
        index = vpe_input_dqbuf(vpe);
        v4l2_qbuf(v4l2, vpe->input_buf_dmafd[index], index);

    }

    MSG("Ok!");
    return NULL;
}

/**
  * @brief  Hough transform the captured image dump and save to file
  * @param  arg: pointer to parameter of thr_data
  * @retval none
  */
void * capture_dump_thread(void *arg)
{
    struct thr_data *data = (struct thr_data *)arg;
    FILE *fp;
    FILE *fp_perspective;
    char file[50];
    char file_perspective[50];
    struct timeval timestamp;
    struct tm *today;
    DumpMsg dumpmsg;

    while(1) {
        if(msgrcv(data->msgq_id, &dumpmsg, sizeof(DumpMsg)-sizeof(long), DUMP_MSGQ_MSG_TYPE, 0) >= 0) {
            switch(dumpmsg.state_msg) {
                case DUMP_CMD :
                    gettimeofday(&timestamp, NULL);
                    today = localtime(&timestamp.tv_sec);
                    sprintf(file, "dump_%04d%02d%02d_%02d%02d%02d.%s", today->tm_year+1900, today->tm_mon+1, today->tm_mday, today->tm_hour, today->tm_min, today->tm_sec,VPE_OUTPUT_FORMAT);
                    sprintf(file_perspective, "perspectiv_image.%s",VPE_OUTPUT_FORMAT);
                    data->dump_state = DUMP_READY;
                    MSG("file name:%s", file);
                    MSG("file name(dump):%s", file_perspective);
                    break;

                case DUMP_WRITE_TO_FILE :
                   
                    if((fp = fopen(file, "w+")) == NULL)
                    {
                        ERROR("Fail to fopen");
                    } else {
                        fwrite(data->dump_img_data, VPE_OUTPUT_IMG_SIZE, 1, fp);
                    }
                    fclose(fp);
                   
                    if((fp_perspective = fopen(file_perspective, "w+")) == NULL){
                        ERROR("Fail to fopen perspectiv");
                    } else {
                        fwrite(dump_img_data_perspective,PERSPEVTIVE_IMG_SIZE, 1, fp_perspective);
                    }
                    fclose(fp_perspective);
                   
                    OpenCV_grayimage_save_file("lanegray.bmp", lanebuf,VPE_OUTPUT_W, VPE_OUTPUT_H);
                    OpenCV_colorimage_save_file("lanecolor.bmp", data->dump_img_data,VPE_OUTPUT_W, VPE_OUTPUT_H);
                   
                    OpenCV_grayimage_save_file("lanep.bmp", lanedistancebuf,PERSPECTIVE_IMG_W ,PERSPECTIVE_IMG_H);
                   
                    cv_savetojpeg(data->dump_img_data,CAPTURE_IMG_W ,CAPTURE_IMG_H);
                    data->dump_state = DUMP_DONE;
                    break;

               case DUMP_WRITE_TO_FILE_JPG :
                    cv_savetojpeg(data->dump_img_data,CAPTURE_IMG_W ,CAPTURE_IMG_H);
                    data->dump_state = DUMP_DONE;
                    break;
                default :
                    MSG("dump msg wrong (%d)", dumpmsg.state_msg);
                    break;
            }
        }
    }

    return NULL;
}

float infra_sensor_volt_to_distance(int ad_value)
{
    float temp;
    float distance;
    temp = ad_value ;
    distance =  19475.78 * pow(temp, -1);
   
    return distance;
}
void * Car_Yaw_Angle_Control_thread(void *arg)
{
    /*
    short angle;
    //Car_Yaw_Angle_data[2];
    while(1)
    {
      if ((lane_position[1][0] !=-1)&&(lane_position[1][1] !=-1))
      { 
             Car_Yaw_Angle_data[0] = ((lane_position[1][1] + lane_position[1][0])/2 - PERSPECTIVE_IMG_W/2    ) /500;
        }
        else if ((lane_position[1][0] ==-1)&&(lane_position[1][1] !=-1))
        {
            lane_position[1][0] = lane_position[1][0] - 380;
            Car_Yaw_Angle_data[0] = ((lane_position[1][0] + lane_position[1][0])/2 - PERSPECTIVE_IMG_W/2    ) /500;
        //    lane_position[1][0] = -1;
      }
        else if ((lane_position[1][0] !=-1)&&(lane_position[1][1] ==-1))
        {
            lane_position[1][1] = lane_position[1][0] + 380;
            Car_Yaw_Angle_data[0] = ((lane_position[1][0] + lane_position[1][0])/2 - PERSPECTIVE_IMG_W/2    ) /500;
        //    lane_position[1][1] = -1;
      }
      else
      {
          Car_Yaw_Angle_data[0] =0;
      }
     angle = 1500 - Car_Yaw_Angle_data[0]*700;          
     SteeringServoControl_Write(angle);     
    // MSG("Steering Angle: %d %6.3lf [%6.3lf %6.3lf]\n", angle,Car_Yaw_Angle_data[0],lane_position[1][0],lane_position[1][1]);
    }
    */
   
    return NULL;
}

void * Car_Speed_Control_thread(void *arg)
{
/*
     short angle;
     
     while(1)
     {
          DesireSpeed_Write(speed);
     }
     * */
    return NULL;
}

void Car_Yaw_Angle_Control(void)
{
   
    short angle;
   
      if ((lane_position[1][0] !=-1)&&(lane_position[1][1] !=-1))
      { 
             Car_Yaw_Angle_data[0] = ((lane_position[1][1] + lane_position[1][0])/2 - PERSPECTIVE_IMG_W/2    ) /500;
        }
        else if ((lane_position[1][0] ==-1)&&(lane_position[1][1] !=-1))
        {
            lane_position[1][0] = lane_position[1][0] - 380;
            Car_Yaw_Angle_data[0] = ((lane_position[1][0] + lane_position[1][0])/2 - PERSPECTIVE_IMG_W/2    ) /500;
        //    lane_position[1][0] = -1;
      }
        else if ((lane_position[1][0] !=-1)&&(lane_position[1][1] ==-1))
        {
            lane_position[1][1] = lane_position[1][0] + 380;
            Car_Yaw_Angle_data[0] = ((lane_position[1][0] + lane_position[1][0])/2 - PERSPECTIVE_IMG_W/2    ) /500;
        //    lane_position[1][1] = -1;
      }
      else
      {
          Car_Yaw_Angle_data[0] =0;
      }
     angle = 1500 - Car_Yaw_Angle_data[0]*700;          
     SteeringServoControl_Write(angle);     
   
   
}

void * Infra_Sensor_Read_thread(void *arg)
{
    //struct thr_data *data = (struct thr_data *)arg;
    /*
    int data;
    int i;
    double angle_r, angle_l, angle_c;

    while(1)
    {         
        for(i=1;i<7;i++)
        {
              data = DistanceSensor(i);
              infared_sensor_distance[i] = infra_sensor_volt_to_distance(data);       
    //       printf("%6.3lf    ", infared_sensor_distance[i]);          
        }          
           angle_r = -( infared_sensor_distance[2]- infared_sensor_distance[3])/28;
           angle_l = ( infared_sensor_distance[6]- infared_sensor_distance[5])/28;
           angle_c = (angle_r + angle_l)/2;
           Car_Yaw_Angle_data[1] = angle_c;
    }
    *
*/
    return NULL;
}

void Infra_Sensor_Reads(void)
{
    //struct thr_data *data = (struct thr_data *)arg;
    int data;
    int i;
    double angle_r, angle_l, angle_c;

    while(1)
    {         
        for(i=1;i<7;i++)
        {
              data = DistanceSensor(i);
              infared_sensor_distance[i] = infra_sensor_volt_to_distance(data);       
    //       printf("%6.3lf    ", infared_sensor_distance[i]);          
        }          
           angle_r = -( infared_sensor_distance[2]- infared_sensor_distance[3])/28;
           angle_l = ( infared_sensor_distance[6]- infared_sensor_distance[5])/28;
           angle_c = (angle_r + angle_l)/2;
           Car_Yaw_Angle_data[1] = angle_c;
    }
}
/**
  * @brief  handling an input command
  * @param  arg: pointer to parameter of thr_data
  * @retval none
  */
void * input_thread(void *arg)
{
    struct thr_data *data = (struct thr_data *)arg;

    char cmd_input[128];
    char cmd_ready = true;

    while(!data->bstream_start) {
        usleep(100*1000);
    }

    MSG("\n\nInput command:");
    MSG("\t dump  : display image(%s, %dx%d) dump", VPE_OUTPUT_FORMAT, VPE_OUTPUT_W, VPE_OUTPUT_H);
    MSG("\n");

    while(1)
    {
        if(cmd_ready == true) {
            /*standby to input command */
            cmd_ready = StandbyInput(cmd_input);     //define in cmd.cpp
        } else {
            if(0 == strncmp(cmd_input,"dump",4))
            {
                DumpMsg dumpmsg;
                dumpmsg.type = DUMP_MSGQ_MSG_TYPE;
                dumpmsg.state_msg = DUMP_CMD;
                data->dump_state = DUMP_CMD;
                MSG("image dump start");
                if (-1 == msgsnd(data->msgq_id, &dumpmsg, sizeof(DumpMsg)-sizeof(long), 0)) {
                    printf("dump cmd msg send fail\n");
                }

                while(data->dump_state != DUMP_DONE)
                {
                    usleep(5*1000);
                }
                data->dump_state = DUMP_NONE;
                MSG("image dump done");
            }
            else
            {
                printf("cmd_input:%s \n", cmd_input);
            }
            cmd_ready = true;
        }
    }

    return NULL;
}

static struct thr_data* pexam_data = NULL;

/**
  * @brief  handling an SIGINT(CTRL+C) signal
  * @param  sig: signal type
  * @retval none
  */
void signal_handler(int sig)
{
    if(sig == SIGINT) {
        pthread_cancel(pexam_data->threads[0]);
        pthread_cancel(pexam_data->threads[1]);
        pthread_cancel(pexam_data->threads[2]);
        pthread_cancel(pexam_data->threads[3]);  // nfrared Sensor Read
        pthread_cancel(pexam_data->threads[4]);  // Car Yaw Control Angle
        pthread_cancel(pexam_data->threads[5]);  // Car Speed Control

        msgctl(pexam_data->msgq_id, IPC_RMID, 0);

        v4l2_streamoff(pexam_data->v4l2);
        vpe_stream_off(pexam_data->vpe->fd, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
        vpe_stream_off(pexam_data->vpe->fd, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);

        disp_free_buffers(pexam_data->vpe->disp, NUMBUF);
        free_input_buffers(pexam_data->input_bufs, NUMBUF, false);
        free_overlay_plane(pexam_data->vpe->disp);

        disp_close(pexam_data->vpe->disp);
        vpe_close(pexam_data->vpe);
        v4l2_close(pexam_data->v4l2);
        printf("-- 6_camera_opencv_disp example End --\n");
    }
}

void init_car(void)
{
   
    CarControlInit();
   
    VisionInit();
    printf("\n\n 0. Initialize Car\n");
    short camera_y_angle;
   
    camera_y_angle = 1700;
    CameraYServoControl_Write(camera_y_angle);
    CameraXServoControl_Write(1517);
    SteeringServoControl_Write(1500);
    sleep(1);   
    PositionControlOnOff_Write(UNCONTROL); // position controller must be OFF !!!
    SpeedControlOnOff_Write(CONTROL);
    DesireSpeed_Write(0);
}
int main(int argc, char **argv)
{
    struct v4l2 *v4l2;
    struct vpe *vpe;
    struct thr_data tdata;
    int disp_argc = 3;
    char* disp_argv[] = {"dummy", "-s", "4:480x272", "\0"}; // AßEA º?°æ ¿ⓒºI E®AI EA A³¸®..
    int ret = 0;
   
    init_car();
    SpeedControlOnOff_Write(UNCONTROL);
    printf("-- 6_camera_opencv_disp example Start --\n");
    lane_position[1][0] = lane_position[1][1] = -1;
   
    tdata.dump_state = DUMP_NONE;
    memset(tdata.dump_img_data, 0, sizeof(tdata.dump_img_data));

    // open vpe
    vpe = vpe_open();
    if(!vpe) {
        return 1;
    }
    // vpe input (v4l cameradata)
    vpe->src.width  = CAPTURE_IMG_W;
    vpe->src.height = CAPTURE_IMG_H;
    describeFormat(CAPTURE_IMG_FORMAT, &vpe->src);

    // vpe output (disp data)
    vpe->dst.width  = VPE_OUTPUT_W;
    vpe->dst.height = VPE_OUTPUT_H;
    describeFormat (VPE_OUTPUT_FORMAT, &vpe->dst);

    vpe->disp = disp_open(disp_argc, disp_argv);
    if (!vpe->disp) {
        ERROR("disp open error!");
        vpe_close(vpe);
        return 1;
    }

    set_z_order(vpe->disp, vpe->disp->overlay_p.id);
    set_global_alpha(vpe->disp, vpe->disp->overlay_p.id);
    set_pre_multiplied_alpha(vpe->disp, vpe->disp->overlay_p.id);
    alloc_overlay_plane(vpe->disp, OVERLAY_DISP_FORCC, 0, 0, OVERLAY_DISP_W, OVERLAY_DISP_H);

    //vpe->deint = 0;
    vpe->translen = 1;

    MSG ("Input(Camera) = %d x %d (%.4s)\nOutput(LCD) = %d x %d (%.4s)",
        vpe->src.width, vpe->src.height, (char*)&vpe->src.fourcc,
        vpe->dst.width, vpe->dst.height, (char*)&vpe->dst.fourcc);

    if (    vpe->src.height < 0 || vpe->src.width < 0 || vpe->src.fourcc < 0 || \
        vpe->dst.height < 0 || vpe->dst.width < 0 || vpe->dst.fourcc < 0) {
        ERROR("Invalid parameters\n");
    }
  
    v4l2 = v4l2_open(vpe->src.fourcc, vpe->src.width, vpe->src.height);
    if (!v4l2) {
        ERROR("v4l2 open error!");
        disp_close(vpe->disp);
        vpe_close(vpe);
        return 1;
    }

    tdata.disp = vpe->disp;
    tdata.v4l2 = v4l2;
    tdata.vpe = vpe;
    tdata.bfull_screen = true;
    tdata.bstream_start = false;

    if(-1 == (tdata.msgq_id = msgget((key_t)DUMP_MSGQ_KEY, IPC_CREAT | 0666)))
    {
        fprintf(stderr, "%s msg create fail!!!\n", __func__);
        return -1;
    }

    pexam_data = &tdata;

    ret = pthread_create(&tdata.threads[0], NULL, capture_thread, &tdata);
    if(ret)
    {
        MSG("Failed creating capture thread");
    }
    pthread_detach(tdata.threads[0]);

    ret = pthread_create(&tdata.threads[1], NULL, capture_dump_thread, &tdata);
    if(ret)
    {
        MSG("Failed creating capture dump thread");
    }
    pthread_detach(tdata.threads[1]);

    ret = pthread_create(&tdata.threads[2], NULL, input_thread, &tdata);
    if(ret)
    {
        MSG("Failed creating input thread");
    }  
    pthread_detach(tdata.threads[2]);
   
    ret = pthread_create(&tdata.threads[3], NULL, Infra_Sensor_Read_thread, &tdata);
    if(ret)
    {
        MSG("Failed creating Obstacle Stop thread");
    }  
    pthread_detach(tdata.threads[3]);

    ret = pthread_create(&tdata.threads[4], NULL, Car_Yaw_Angle_Control_thread, &tdata);
    if(ret)
    {
        MSG("Failed creating Car Yaw Control thread");
    }  
    pthread_detach(tdata.threads[4]);

    ret = pthread_create(&tdata.threads[5], NULL, Car_Speed_Control_thread, &tdata);
    if(ret)
    {
        MSG("Failed creating Car Yaw Control thread");
    }  
    pthread_detach(tdata.threads[5]);

    /* register signal handler for <CTRL>+C in order to clean up */
    if(signal(SIGINT, signal_handler) == SIG_ERR) {
        MSG("could not register signal handler");
        closelog();
        exit(EXIT_FAILURE);
    }
   
  
    pause();

    return ret;
} 

 

 

 

--------------------------swcar_image processing.c------------------------------------

#include "swcar_imageprocessing.h"


void Threshold(unsigned char *Image_Input, unsigned char *Image_Output, cSize Image_size, cRect ROI,int threshold, int type)
{
    int i, j;
    unsigned char *Temp_Image;
   
    Temp_Image= new unsigned char[Image_size.cx*Image_size.cy];
   
    if (type == 0)
    {
        for (i = 0; i<Image_size.cy; i++)
        {
            for (j = 0; j<Image_size.cx; j++)
            {
                if (j >= ROI.left && j<ROI.right && i >= ROI.top && i<ROI.bottom)
                {

                    if (*(Image_Input + j + i*Image_size.cx) >= threshold)
                    {
                        *(Temp_Image + j + i*Image_size.cx) = 0;
                    }
                    else
                    {
                        *(Temp_Image + j + i*Image_size.cx) = 255;
                    }
                }
            }
        }

    }

    else
    {
        for (i = 0; i<Image_size.cy; i++)
        {
            for (j = 0; j<Image_size.cx; j++)
            {
                if (j >= ROI.left && j<ROI.right && i >= ROI.top && i<ROI.bottom)
                {
                    if (*(Image_Input + j + i*Image_size.cx) >= threshold)
                    {
                        *(Temp_Image + j + i*Image_size.cx) = 255;
                    }
                    else
                    {
                        *(Temp_Image + j + i*Image_size.cx) = 0;
                    }

                }
            }
        }
    }
    /*
    for (i = 0; i<Image_size.cy; i++)
    {
            for (j = 0; j<Image_size.cx; j++)
            {
                *(Image_Output+ j + i*Image_size.cx)= *(Temp_Image+ j + i*Image_size.cx);
            }
           
    }
    */
    memcpy(Image_Output, Temp_Image, Image_size.cx*Image_size.cy);
   
    delete[] Temp_Image;
}


void Threshold2(BYTE *Image_Input, BYTE *Image_Output,cSize Image_size,cRect ROI, int threshold1,int threshold2)
{

    int i,j;

    unsigned char *Temp_Image;
   
    Temp_Image= new unsigned char[Image_size.cx*Image_size.cy];
   
        for(i=0;i<Image_size.cy;i++)
        {
            for(j=0;j<Image_size.cx;j++)
            {
                if(j>=ROI.left && j<ROI.right && i>=ROI.top && i<ROI.bottom)
                {

                    if( (*(Image_Input+j+i*Image_size.cx) >= threshold1) && (*(Image_Input+j+i*Image_size.cx) <= threshold2) )
                    {
                        *(Temp_Image+j+i*Image_size.cx) =   255;
                    }
                    else
                    {
                        *(Temp_Image+j+i*Image_size.cx) =   0;
                    }
                }   
            }
        }

   memcpy(Image_Output, Temp_Image, Image_size.cx*Image_size.cy);
   delete[] Temp_Image;
}

void Find_Blob_Center(UINT *Label_Result,cSize Image_size,cRect ROI,double *m_center_blob_x,double *m_center_blob_y, int no_blob, unsigned long *area)
{

    int i,j,k;
    unsigned long *c_x,*c_y;

    if (no_blob == 0) return;

    c_x = new unsigned long[no_blob+1];
    c_y = new unsigned long[no_blob+1];


    memset(c_x, 0, (no_blob+1)*sizeof(unsigned long));
    memset(c_y, 0, (no_blob+1)*sizeof(unsigned long));
    memset(area, 0, (no_blob+1)*sizeof(unsigned long));

    for(i=ROI.top; i< ROI.bottom; i++)
    {

        for(j=ROI.left; j < ROI.right; j++)
        {

            k =*(Label_Result+j+i*Image_size.cx);

            if( ( k>=1 )&& (k<=no_blob) )
            {
                *(area + k) += 1;
                *(c_x  + k) += j;
                *(c_y  + k) += i;
            }
        }
    }
    for(k=1;k<no_blob+1;k++)
    {
        *(m_center_blob_x+k) = (double)( (double)*(c_x+k) / (double)*(area+k));
        *(m_center_blob_y+k) = (double)( (double)*(c_y+k) / (double)*(area+k));       
    }
   
    delete []c_x;
    delete []c_y;
}
long Find_Center(BYTE *Image_Input,cSize Image_size, cRect ROI,double *m_center_x,double *m_center_y, int threshold, int type)
{

    int i,j;
    BYTE *Image_Output;
    long area_sum;
    long c_x,c_y;
    Image_Output = new BYTE[Image_size.cx*Image_size.cy];


    if(type == 0)
    {
        for(i=0,area_sum=0,c_x=0,c_y=0;i<Image_size.cy;i++)
        {
            for(j=0;j<Image_size.cx;j++)
            {
                if(j>=ROI.left && j<ROI.right && i>=ROI.top && i<ROI.bottom)
                {

                    if(*(Image_Input+j+i*Image_size.cx) >= threshold)
                    {
                        *(Image_Output+j+i*Image_size.cx) =     0;
                    }
                    else
                    {
                        *(Image_Output+j+i*Image_size.cx) =   255;
                        area_sum++;
                        c_x += j;
                        c_y += i;
                    }
                }   
            }
        }

    }

    else
    {
        for(i=0,area_sum=0,c_x=0,c_y=0;i<Image_size.cy;i++)
        {
            for(j=0;j<Image_size.cx;j++)
            {
                if(j>=ROI.left && j<ROI.right && i>=ROI.top && i<ROI.bottom)
                {
                    if(*(Image_Input+j+i*Image_size.cx) >= threshold)
                    {
                        *(Image_Output+j+i*Image_size.cx) =   255;
                        area_sum++;
                        c_x += j;
                        c_y += i;
                    }
                    else
                    {
                        *(Image_Output+j+i*Image_size.cx) =   0;
                    }

                }
            }
        }
    }


    *m_center_x = ( (double)c_x/(double)area_sum );
    *m_center_y = ( (double)c_y/(double)area_sum );



    delete []Image_Output;

    return area_sum;
}


int push(int *stackx, int *stacky, int vx, int vy, int *top,int maxsize)
{
    if(*top>=maxsize) return(-1);
    (*top)++;
    stackx[*top]=vx;
    stacky[*top]=vy;
    return(1);
}

int pop(int *stackx, int *stacky, int *vx, int *vy, int *top)
{
    if(*top<=0) return(-1);
    *vx=stackx[*top];
    *vy=stacky[*top];
    (*top)--;
    return(1);;
}

void Dilation(BYTE *Input_Image, BYTE *Output_Image,cSize image_size)
{

   
    int i,j;
    BYTE *temp_image;
    temp_image = new BYTE[image_size.cy* image_size.cx];

    memset(temp_image,0, image_size.cy* image_size.cx*sizeof(BYTE));

    for(i=1; i<image_size.cy-1; i++)
    {
        for(j=1; j<image_size.cx-1; j++)
        {
            // Image Contraction
            *(temp_image+i*image_size.cx+j) = *(Input_Image+i*image_size.cx+j);

            if( *(Input_Image+(i-1)*image_size.cx + (j-1) ) == 255   ) *(temp_image+i*image_size.cx+j) = 255;
            if( *(Input_Image+(i-1)*image_size.cx + (j  ) ) == 255   ) *(temp_image+i*image_size.cx+j) = 255;
            if( *(Input_Image+(i-1)*image_size.cx + (j+1) ) == 255   ) *(temp_image+i*image_size.cx+j) = 255;

            if( *(Input_Image+(i  )*image_size.cx + (j-1) ) == 255   ) *(temp_image+i*image_size.cx+j) = 255;
            if( *(Input_Image+(i  )*image_size.cx + (j  ) ) == 255   ) *(temp_image+i*image_size.cx+j) = 255;
            if( *(Input_Image+(i  )*image_size.cx + (j+1) ) == 255   ) *(temp_image+i*image_size.cx+j) = 255;

            if( *(Input_Image+(i+1)*image_size.cx + (j-1) ) == 255   ) *(temp_image+i*image_size.cx+j) = 255;
            if( *(Input_Image+(i+1)*image_size.cx + (j  ) ) == 255   ) *(temp_image+i*image_size.cx+j) = 255;
            if( *(Input_Image+(i+1)*image_size.cx + (j+1) ) == 255   ) *(temp_image+i*image_size.cx+j) = 255;


        } // end of j
    } // end of i

    for(i=0; i<image_size.cy; i++)
    {
        for(j=0; j<image_size.cx; j++)
        {
            *(Output_Image+i*image_size.cx+j) =*(temp_image+i*image_size.cx+j);
        }
    }

    delete []temp_image;

}


void Erode(BYTE *Input_Image, BYTE *Output_Image,cSize image_size)
{


    int i,j;
    BYTE *temp_image;
    temp_image = new BYTE[image_size.cy* image_size.cx];

    memset(temp_image,0, image_size.cy* image_size.cx*sizeof(BYTE));

    for(i=1; i<image_size.cy-1; i++)
    {
        for(j=1; j<image_size.cx-1; j++)
        {
            // Image Contraction
            *(temp_image+i*image_size.cx+j) = *(Input_Image+i*image_size.cx+j);

            if( *(Input_Image+(i-1)*image_size.cx + (j-1) ) == 0   ) *(temp_image+i*image_size.cx+j) = 0;
            if( *(Input_Image+(i-1)*image_size.cx + (j  ) ) == 0   ) *(temp_image+i*image_size.cx+j) = 0;
            if( *(Input_Image+(i-1)*image_size.cx + (j+1) ) == 0   ) *(temp_image+i*image_size.cx+j) = 0;

            if( *(Input_Image+(i  )*image_size.cx + (j-1) ) == 0   ) *(temp_image+i*image_size.cx+j) = 0;
            if( *(Input_Image+(i  )*image_size.cx + (j  ) ) == 0   ) *(temp_image+i*image_size.cx+j) = 0;
            if( *(Input_Image+(i  )*image_size.cx + (j+1) ) == 0   ) *(temp_image+i*image_size.cx+j) = 0;

            if( *(Input_Image+(i+1)*image_size.cx + (j-1) ) == 0   ) *(temp_image+i*image_size.cx+j) = 0;
            if( *(Input_Image+(i+1)*image_size.cx + (j  ) ) == 0   ) *(temp_image+i*image_size.cx+j) = 0;
            if( *(Input_Image+(i+1)*image_size.cx + (j+1) ) == 0   ) *(temp_image+i*image_size.cx+j) = 0;

        } // end of j
    } // end of i

    for(i=0; i<image_size.cy; i++)
    {
        for(j=0; j<image_size.cx; j++)
        {
            *(Output_Image+i*image_size.cx+j) =*(temp_image+i*image_size.cx+j);
        }
    }
    delete []temp_image;
}

void Erode_ROI(BYTE *Input_Image, BYTE *Output_Image, cSize image_size,cRect ROI)
{


    int i, j;
    BYTE *temp_image;
    temp_image = new BYTE[image_size.cy* image_size.cx];

    memset(temp_image, 0, image_size.cy* image_size.cx*sizeof(BYTE));

    for (i = ROI.top + 1; i<ROI.bottom - 1; i++)
    {
        for (j = ROI.left+1; j<ROI.right - 1; j++)
        {
            // Image Contraction
            *(temp_image + i*image_size.cx + j) = *(Input_Image + i*image_size.cx + j);

            if (*(Input_Image + (i - 1)*image_size.cx + (j - 1)) == 0) *(temp_image + i*image_size.cx + j) = 0;
            if (*(Input_Image + (i - 1)*image_size.cx + (j)) == 0) *(temp_image + i*image_size.cx + j) = 0;
            if (*(Input_Image + (i - 1)*image_size.cx + (j + 1)) == 0) *(temp_image + i*image_size.cx + j) = 0;

            if (*(Input_Image + (i)*image_size.cx + (j - 1)) == 0) *(temp_image + i*image_size.cx + j) = 0;
            if (*(Input_Image + (i)*image_size.cx + (j)) == 0) *(temp_image + i*image_size.cx + j) = 0;
            if (*(Input_Image + (i)*image_size.cx + (j + 1)) == 0) *(temp_image + i*image_size.cx + j) = 0;

            if (*(Input_Image + (i + 1)*image_size.cx + (j - 1)) == 0) *(temp_image + i*image_size.cx + j) = 0;
            if (*(Input_Image + (i + 1)*image_size.cx + (j)) == 0) *(temp_image + i*image_size.cx + j) = 0;
            if (*(Input_Image + (i + 1)*image_size.cx + (j + 1)) == 0) *(temp_image + i*image_size.cx + j) = 0;

        } // end of j
    } // end of i

    for (i = 0; i<image_size.cy; i++)
    {
        for (j = 0; j<image_size.cx; j++)
        {
            *(Output_Image + i*image_size.cx + j) = *(temp_image + i*image_size.cx + j);
        }
    }

    delete[]temp_image;

}

void Calculation_Center_BinaryImage(BYTE *Bin_Image, cSize image_size, double *x_c, double *y_c)
{
    int x, y;
    int height = image_size.cy;
    int width = image_size.cx;
    UINT area;
    UINT x_sum;
    UINT y_sum;

    area = x_sum = y_sum = 0;
    for (y = 0; y < height; y++)
    {
        for (x = 0; x < width; x++)
        {
            if (*(Bin_Image + y * width + x) == 255)
            {
                area++;
                x_sum += x;
                y_sum += y;
            }
        }
    }

    *x_c = (double)x_sum / (double)area;
    *y_c = (double)y_sum / (double)area;

}

void Projection_H(BYTE *In_Image, cSize image_size, cRect ROI, double *projection_h)
{

    int x, y;
    int height = image_size.cy;
    int width = image_size.cx;

    memset(projection_h, 0, height*sizeof(double)) ;

   
    for (y = ROI.top; y < ROI.bottom; y++)
    {
        for (x = ROI.left; x < ROI.right; x++)
        {
            *(projection_h + y) += (double)(*(In_Image + y*width + x) );///(255.0);
        }

            *(projection_h + y)  /= (ROI.right-ROI.left);
    }

   // printf("ROI_width : %d\n",ROI.Width);
}

void Projection_V(BYTE *In_Image, cSize image_size, cRect ROI, double *projection_v)
{

    int x, y;
//    int height = image_size.cy;
    int width = image_size.cx;

    memset(projection_v, 0, width*sizeof(double));

    for (x = ROI.left; x < ROI.right; x++)
    {
        for (y = ROI.top; y < ROI.bottom; y++)
        {
            *(projection_v + x) += (double)(*(In_Image + y*width + x)   );///(255.0);
        }
          *(projection_v + x)  /= (ROI.bottom-ROI.top);
    }
       // printf("%d\n",ROI.Height);
}


void grass(int *projection_temp, BYTE *Label, int size_projection, int i, int no_label)
{

    int k, index;
    //int height;
    int width;

    //height = 1;
    width = size_projection;


    for (k = i - 1; k <= i + 1; k++)
    {
        // 영상의 경계를 벗어나면 라벨링하지 않음
        if (k<0 || k > width) continue;

        index = k;
        // 아직 방문하지 않은 픽셀이고 값이 255라면 라벨링함
        if (*(projection_temp + k) == 255 && *(Label + index) == 0)
        {
            *(Label + index) = no_label;

            grass(projection_temp, Label, size_projection, k, no_label);
        }

    }

}
cRect Set_ROI(int x1,int y1,int x2, int y2)
{
    cRect temp;
   
    temp.left    = x1;
    temp.right   = x2;   
    temp.top     =  y1;
    temp.bottom  = y2;
   
   
    return temp;

}

void Find_ProjectData_Center_Position(double *projection, int size_projection, int threshold, double *position, int *no_pad, cSize* Projection_Blob)
{

    int x, k;
    int start_x, no_data;
    double position_sum;
    int *projection_temp;
    BYTE *Label;
    int no_label = 0;
    int max_pos, min_pos;
    int index_cnt = 0;
    int m_max_label =50;
    int m_min_distance=3;
    int m_max_distance=110;
   
    projection_temp = new int[size_projection];
    Label = new BYTE[size_projection];
   
    // Initialize
    memset(Label, 0, size_projection*sizeof(BYTE));
    memset(projection_temp, 0, size_projection*sizeof(int));


    for (x = 0; x < size_projection; x++)
    {
        if (*(projection + x) >= threshold)
        {
            *(projection_temp + x) = 255;
        }
        else
        {
            *(projection_temp + x) = 0;
        }
    }

    no_label = 0;
    for (x = 0; x < size_projection; x++)
    {
        if (*(projection_temp + x) == 255 && *(Label + x) == 0)
        {
            no_label++;
            *(Label + x) = no_label;
             grass(projection_temp, Label, size_projection, x, no_label);
        }
    }

    start_x = 0;
    no_label = (no_label > m_max_label) ? m_max_label : no_label;
    for (k = 1, index_cnt = 0; k <= no_label; k++)
    {
        position_sum = 0;
        no_data = 0;
        max_pos = 0, min_pos = size_projection;
        for (x = start_x; x < size_projection; x++)
        {
            if (*(Label + x) == k)
            {
                position_sum += (double)x;
                no_data++;
                start_x = x;

                if (max_pos <= x)  max_pos = x;
                if (min_pos >= x)  min_pos = x;
            }
        }

        *(position + k - 1) = position_sum / no_data;
        Projection_Blob[index_cnt].cx = min_pos;
        Projection_Blob[index_cnt].cy = max_pos;
       
       //printf("min_pos %3d / max_pos %3d  index_cnt %3d\n", min_pos, max_pos,index_cnt);
       //printf("distancs_pos : %3d\n", max_pos-min_pos);
           
        if ( ((max_pos - min_pos) >= m_min_distance) && ((max_pos - min_pos) <= m_max_distance) )
        {
          index_cnt++;
        }

    }
    *no_pad = index_cnt;

    /*
    for (k = 1; k <= no_label; k++)
    {
    max_pos = 0, min_pos = size_projection;

    for (x = start_x; x < size_projection; x++)
    {
    if (*(Label + x) == k)
    {
    if (max_pos <= x)  max_pos = x;
    if (min_pos >= x)  min_pos = x;
    }
    }
    *(position + k - 1)
    }
    */

    /*
    FILE *fp;

    fp = fopen("D:\\kkw\\data\\projection_data3.txt", "wt");

    for (x = 0; x < no_label; x++)
    {
    fprintf(fp, " %d  %lf   \n", x, *(position + x));
    }
    fclose(fp);
    */


    delete[]projection_temp;
    delete[]Label;
}


void save_projection_data(char *filename, double *projection, int size_project)
{
    FILE *fp;
    int x;
   
    fp = fopen(filename,"w");
    if(fp==NULL)
    {
       printf("file error\n");
       return;
    }
       
    for (x = 0; x < size_project; x++)
    {
        fprintf(fp, " %6.4lf \n", *(projection + x));
    }
      fclose(fp);
   
}


int Blob_Analysis2(BYTE *Binary_Image, UINT *Label_Image, cSize image_size,unsigned long min_area,unsigned long max_area)
{
    //

    UINT *label_image_temp;

    int i,j,m,n,top;
    UINT  curColor=0;
    int r,c;
    int k;
    unsigned long area,BlobArea[MAX_NO_BLOB];

    int no_blob=0;
    int width = image_size.cx;
    int height =image_size.cy;

    // 스택으로 사용할 메모리 할당
    int* stackx=new int [height*width];
    int* stacky=new int [height*width];

    label_image_temp = new UINT[height*width];

    // 라벨링된 픽셀을 저장하기 위해 메모리 할당
    //short *label_Image = new short [height*width];
    for(i=0; i<height*width; i++)  label_image_temp[i] = Label_Image[i]=0; //메모리 초기화

    //    max_area = height*width; //     min_area = 1000;


    //    for(i=0; i<5; i++)    
    //    Erode(binary_image,binary_image,image_size);


    for(i=0,no_blob=0; i<height; i++)
    {
        for(j=0; j<width; j++)
        {   
            // 이미 방문한 점이거나 픽셀값이 255가 아니라면 처리 안함
            if(label_image_temp[i*width+j]!=0 || Binary_Image[i*width+j]!=m_FORGROUND) continue;

            r=i;
            c=j;
            top=0; area=1;
            curColor++;

            while(1)
            {
GRASSFIRE:
                for(m=r-1; m<=r+1; m++)
                {
                    for(n=c-1; n<=c+1; n++)
                    {
                        // 관심 픽셀이 영상경계를 벗어나면 처리 안함 
                        if(m<0 || m>=height || n<0 || n>=width) continue;

                        if(Binary_Image[m*width+n]==m_FORGROUND && label_image_temp[m*width+n]==0)
                        {
                            label_image_temp[m*width+n]=curColor;  // 현재 라벨로 마크
                            if(push(stackx,stacky,m,n,&top, width*height)==-1) continue;
                            r=m;
                            c=n;
                            area++;
                            goto GRASSFIRE;
                        }
                    }
                }
                if(pop(stackx,stacky,&r,&c,&top)==-1) break;
            }

            if(curColor<MAX_NO_BLOB) BlobArea[curColor] = area;

            //printf("Blob Area[%d] = %d\n", (int)curColor,area);




            // --------------------------------------------------------
            // Blob 면적에 따라 새롭게 label을 부여한다.
            if( (area >= min_area) &&(area <= max_area))
            {

                for(k=0; k<height*width; k++) 
                {
                    if(label_image_temp[k]== curColor) Label_Image[k] = no_blob+1;
                }

                //    printf("Blob[%d] Area %d\n", no_blob, area);
                no_blob++;
            }
            // --------------------------------------------------------
        }
    }
   
    delete label_image_temp;
    delete []stackx; delete []stacky;
   
    return no_blob;
}

int Blob_Analysis_ROI(BYTE *Binary_Image, UINT *Label_Image, cSize image_size,cRect ROI, unsigned int min_area, unsigned int max_area)
{
    //
    UINT *label_image_temp;

    int i, j, m, n, top;
    UINT  curColor = 0;
    int r, c;
    int k;
    unsigned long area, BlobArea[MAX_NO_BLOB];

    int no_blob = 0;
    int width = image_size.cx;
    int height = image_size.cy;

    // 스택으로 사용할 메모리 할당
    int* stackx = new int[height*width];
    int* stacky = new int[height*width];

    label_image_temp = new unsigned int[height*width];

    // 라벨링된 픽셀을 저장하기 위해 메모리 할당
    //short *label_Image = new short [height*width];
    for (i = 0; i<height*width; i++)  label_image_temp[i] = Label_Image[i] = 0; //메모리 초기화
    //    max_area = height*width; //     min_area = 1000;
    //    for(i=0; i<5; i++)    
    //    Erode(binary_image,binary_image,image_size);

    for (i = ROI.top, no_blob = 0; i<ROI.bottom; i++)
    {
        for (j = ROI.left; j<ROI.right; j++)
        {
            // 이미 방문한 점이거나 픽셀값이 255가 아니라면 처리 안함
            if (label_image_temp[i*width + j] != 0 || Binary_Image[i*width + j] != m_FORGROUND) continue;

            r = i;
            c = j;
            top = 0; area = 1;
            curColor++;

            while (1)
            {
            GRASSFIRE:
                for (m = r - 1; m <= r + 1; m++)
                {
                    for (n = c - 1; n <= c + 1; n++)
                    {
                        // 관심 픽셀이 영상경계를 벗어나면 처리 안함 
                        if (m<0 || m >= height || n<0 || n >= width) continue;

                        if (Binary_Image[m*width + n] == m_FORGROUND && label_image_temp[m*width + n] == 0)
                        {
                            label_image_temp[m*width + n] = curColor;  // 현재 라벨로 마크
                            if (push(stackx, stacky, m, n, &top, width*height) == -1) continue;
                            r = m;
                            c = n;
                            area++;
                            goto GRASSFIRE;
                        }
                    }
                }
                if (pop(stackx, stacky, &r, &c, &top) == -1) break;
            }

            if (curColor<MAX_NO_BLOB) BlobArea[curColor] = area;
           
            //printf("Blob Area[%d] = %d\n", (int)curColor, area);
           
            // --------------------------------------------------------
            // Blob 면적에 따라 새롭게 label을 부여한다.
            if ((area >= min_area) && (area <= max_area))
            {
                for (k = 0; k<height*width; k++)
                {
                    if (label_image_temp[k] == curColor) Label_Image[k] = no_blob + 1;
                }

                //    printf("Blob[%d] Area %d\n", no_blob, area);
                no_blob++;
            }
            // --------------------------------------------------------
        }
    }


    delete label_image_temp;
    delete[]stackx; delete[]stacky;

    return no_blob;
}


double LinearCurveFitting_H(cPoint* data, int length, double *aa, double *bb)
{
    // y=a x +b
    double sumx = 0, sumy = 0, sumxy = 0, sumx2 = 0;
    double a = 0.0, b = 0.0;
    double angle; //
    int no_data =0;
    for (int i = 0; i < length; i++)
    {
        if(data[i].y != -1)
        {
            sumx += data[i].x;
            sumy += data[i].y;
            sumx2 += data[i].x * data[i].x;
            sumxy += data[i].x * data[i].y;
         //   printf("point (%d,%d) \n", data[i].x, data[i].y);
            no_data ++;
        }
    }
    if (length*sumx2 == sumx*sumx)    // can not divide by zero
    {
        angle = -90;
    }

    else
    {
        a = (((double)no_data*sumxy - sumx*sumy) / ((double)no_data*sumx2 - sumx*sumx));
        b = ((sumy - a*sumx) / (double)no_data);   
        angle = atan(a) *  180.0 / PI;
        printf("The line is Y=%3.3f +%3.3f X,   angle=%lf degree\n", b, a, angle);
        *aa = a;
        *bb = b;
    }
    return angle;
}

double LinearCurveFitting_V(cPoint* data, int length, double *cc, double *dd)
{
    // x=c*y +d
    double sumx = 0, sumy = 0, sumxy = 0, sumx2 = 0;
    double a = 0.0, b = 0.0;
    double angle;
    int no_data =0;   

    for (int i = 0; i < length; i++)
    {
       if(data[i].x!= -1)
       {
        sumx += data[i].y;
        sumy += data[i].x;
        sumx2 += data[i].y * data[i].y;
        sumxy += data[i].x * data[i].y;
    //    printf("The line is Y=%3.3f +%3.3f X,   angle=%lf degree\n", b, a, angle);
        no_data ++;
       }
    }
    if (length*sumx2 == sumx*sumx)    // can not divide by zero
    {
        angle = -90;
    }

    else
    {
        a = (((double)no_data*sumxy - sumx*sumy) / ((double)no_data*sumx2 - sumx*sumx));
        b = ((sumy - a*sumx) / (double)no_data);
        angle = atan(a) *  180.0 / PI;
         printf("The line is X=%3.3f +%3.3f Y,   angle=%lf degree\n", b, a, angle);
        *cc = a;
        *dd = b;
    }
    return angle;
}


void  Lane_detection_dynamic_threshold(double *in_projection, double *out_projection, int size_projection, int offset, int  threshold)
{


    int x;
   
    double *temp1, *temp2;

   
    temp1 = new double[size_projection];
    temp2 = new double[size_projection];

    memset(temp1, 0, sizeof(double)*size_projection);
    memset(temp2, 0, sizeof(double)*size_projection);

    Lane_Low_pass_filter(in_projection, temp1, size_projection);

    for (x = 0; x < size_projection; x++)
    {

        *(temp2 + x) = *(in_projection + x) - *(temp1 + x) - offset;

        if (*(temp2 + x) > threshold)     *(out_projection + x) = 255;
        else                                  *(out_projection + x) = 0;
    }


    delete[] temp1;
    delete[] temp2;

}

void Lane_High_pass_filter(double *in_projection, double *out_projection, int size_projection)
{

    int x;
    double tau;
    double ts;
    double *temp1, *temp2;
    double mult;

    tau = 0.2;
    ts = 0.01;
    temp1 = new double[size_projection];
    temp2 = new double[size_projection];

    memset(temp1, 0, sizeof(double)*size_projection);
    memset(temp2, 0, sizeof(double)*size_projection);


    mult = tau / (tau + ts);

    *temp1 = 0;
    for (x = 1; x < size_projection; x++)
    {
        *(temp1 + x) = mult *(*(temp1 + x - 1) + *(in_projection + x) - *(in_projection + x - 1));
    }

    *(temp2 + size_projection - 1) = 0;
    *temp2 = 0;

    for (x = size_projection - 2; x >= 1; x--)
    {
        *(temp2 + x) = mult *(*(temp1 + x + 1) + *(in_projection + x - 1) - *(in_projection + x));
    }

    for (x = 0; x < size_projection; x++)
    {

        *(out_projection + x) = (*(temp1 + x) + *(temp2 + x)) / 2;

    }
    delete[] temp1;
    delete[] temp2;
}
void  Lane_Low_pass_filter(double *in_projection, double *out_projection, int size_projection)
{
    int x;
    double tau;
    double ts;
    double *temp1, *temp2;

    tau = 0.8;  //1
    ts = 0.01;
    temp1 = new double[size_projection];
    temp2 = new double[size_projection];

    memset(temp1, 0, sizeof(double)*size_projection);
    memset(temp2, 0, sizeof(double)*size_projection);

    *temp1 = *in_projection;
    for (x = 1; x < size_projection; x++)
    {
        *(temp1 + x) = (tau * *(temp1 + x - 1) + ts * *(in_projection + x)) / (ts + tau);
    }

    *(temp2 + size_projection - 1) = *(in_projection + size_projection - 1);

    for (x = size_projection - 2; x >= 0; x--)
    {
        *(temp2 + x) = (tau * *(temp2 + x + 1) + ts * *(in_projection + x)) / (ts + tau);
    }

    for (x = 0; x < size_projection; x++)
    {

        *(out_projection + x) = (*(temp1 + x) + *(temp2 + x)) / 2;

    }
    delete[] temp1;
    delete[] temp2;

}


void Lane_detection(BYTE *Image_Input, cSize image_size, cRect ROI, int threshold)
{
    int y;
    int no_lane;

    double *projection_v;
    double *lane_raw_data;

    double *lane_highpass_data;
    double *lane_lowpass_data;
    double *lane_filter_data;

    double *lane_center_position;
    cSize  *lane_pos;

    projection_v = new double[image_size.cx];
    lane_raw_data = new double[image_size.cx];

    lane_center_position = new double[50];
    lane_pos = new cSize[50];

    lane_highpass_data = new double[image_size.cx];
    lane_lowpass_data  = new double[image_size.cx];
    lane_filter_data   = new double[image_size.cx];

    memset(lane_raw_data, 0, sizeof(double)*image_size.cx);
    memset(lane_highpass_data, 0, sizeof(double)*image_size.cx);
    memset(lane_lowpass_data, 0, sizeof(double)*image_size.cx);
    memset(lane_filter_data, 0, sizeof(double)*image_size.cx);

    threshold = 200;
    //Set_ROI(int x1, int y1, int x2, int y2);

    for (y = ROI.top; y < ROI.bottom; y++)
    {
        Projection_V(Image_Input, image_size, ROI, projection_v);
        Lane_Low_pass_filter(projection_v, lane_lowpass_data, image_size.cx);
        Lane_High_pass_filter(projection_v, lane_highpass_data, image_size.cx);
        Lane_detection_dynamic_threshold(projection_v, lane_filter_data, image_size.cx, 10, 30);
        Find_ProjectData_Center_Position(lane_filter_data, image_size.cx, threshold, lane_center_position, &no_lane, lane_pos);
    }


    delete[] lane_center_position;
    delete[] lane_pos;
    delete[] projection_v;
    delete[] lane_raw_data;

    delete[] lane_highpass_data;
    delete[] lane_lowpass_data;
    delete[] lane_filter_data;

} 

 

 

----------------------------------------------------exam_cv.cpp-----------------------------------------------

 
#include <iostream>
#include <stdio.h>
#include <string.h>
//#include <sys/time.h>
 
#include <opencv2/opencv.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
//#include <opencv2/gpu/device/utility.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/objdetect/objdetect.hpp>
#include  "exam_cv.h"
 
#define ROI_Y_OFFSET 30
 
using namespace std;
using namespace cv;
 
// Define ROI
 
extern float lane_position[3][2];
 
extern "C" {
     
void OpenCV_grayimage_save_file(char* file, unsigned char* inBuf, int nw, int nh)
{
    //Mat dstRGB;
    Mat dstGRAY(nh, nw, CV_8UC1, inBuf);
  // cvtColor(dstRGB, dstGRAY, CV_GRY2RGB);
    imwrite(file, dstGRAY); // gray image
    //cvtColor(srcRGB, srcRGB, CV_RGB2BGR);
}
 
void OpenCV_colorimage_save_file(char* file, unsigned char* inBuf, int nw, int nh)
{
     
    Mat dstCOLOR(nh, nw, CV_8UC3, inBuf);
    imwrite(file, dstCOLOR); // color image    
}
 
 
void OpenCV_Lane_YawAngle_Calculation(unsigned char* srcBuf, int iw,int ih)
{
    int i,j; 
    int no_lane;
    int roi_height = 10;
    int v_sensor_position[3];
    int threshold = 200;
    int lane_width;
    int line_width[2];
    double projection_v[PERSPECTIVE_IMG_W];
    double lane_center_position[100];
    
    cSize image_size;
    cSize lane_pos[100];    
    cRect ROI;
    
    image_size.cx = PERSPECTIVE_IMG_W;
    image_size.cy = PERSPECTIVE_IMG_H;    
             
    v_sensor_position[0] = 225-120;
    v_sensor_position[1] = 225;
    v_sensor_position[2] = 225+120;
     
    ROI_Lane_Center_Check[0] = Set_ROI(0,v_sensor_position[0] - roi_height,PERSPECTIVE_IMG_W, v_sensor_position[0] + roi_height);
    ROI_Lane_Center_Check[1] = Set_ROI(0,v_sensor_position[1] - roi_height,PERSPECTIVE_IMG_W, v_sensor_position[1] + roi_height);
    ROI_Lane_Center_Check[2] = Set_ROI(0,v_sensor_position[2] - roi_height,PERSPECTIVE_IMG_W, v_sensor_position[2] + roi_height);     
    ROI =  Set_ROI(0,v_sensor_position[0] - roi_height,PERSPECTIVE_IMG_W, v_sensor_position[0] + roi_height);
     
     
    for(i=0;i<3;i++)
    {
       Projection_V(srcBuf, image_size,ROI_Lane_Center_Check[i], projection_v);
       Find_ProjectData_Center_Position(projection_v, PERSPECTIVE_IMG_W, threshold, lane_center_position, &no_lane, lane_pos);
    // if :the number of detection lane is 2
       switch(no_lane)
       {
           case 2:               
                   line_width[i] = lane_pos[0].cy - lane_pos[0].cx;
                   
                   lane_width =  lane_center_position[1]-  lane_center_position[0];
                   
                   if( (lane_width < 400) && (lane_width>=300))
                   {
                       lane_position[i][0] = lane_center_position[0];
                       lane_position[i][1] = lane_center_position[1];           
                   }
                   break;
           case 1:        
                    if(lane_center_position[0] >= PERSPECTIVE_IMG_W/2 ) 
                    {
                       lane_position[i][0] = -1;
                       lane_position[i][1] = lane_center_position[0];         
                    }
                    if(lane_center_position[0] <= PERSPECTIVE_IMG_W/2 ) 
                    {
                       lane_position[i][0] = lane_center_position[0];
                       lane_position[i][1] = -1;         
                    }
             
                   break;
           case 0 :  //no detection
           
                       lane_position[i][0] = -1; 
                       lane_position[i][1] = -1; 
                   break;
                 
           //Car_Yaw_Angle_data[i]           
       }
       
       
       
    }
 
}
 
 
 
 
void OpenCV_Lane_Detection(unsigned char* srcBuf, int iw,int ih, unsigned char* resultBuf)
{
    int i,j,y;
    int lane_offset = 10;
    int no_lane=0;
    int threshold = 200;
    unsigned char outBuf[VPE_OUTPUT_W*VPE_OUTPUT_H];    
    cRect ROI_Lane;
    cRect ROI;
    cSize image_size;
    cSize lane_pos[100];    
    double projection_v[VPE_OUTPUT_W];
    double lane_lowpass_data[VPE_OUTPUT_W];
    double lane_highpass_data[VPE_OUTPUT_W];
    double lane_filter_data[VPE_OUTPUT_W];
    double lane_center_position[100];
    
    image_size.cx = VPE_OUTPUT_W;
    image_size.cy = VPE_OUTPUT_H;
    
    Mat srcRGB(ih, iw, CV_8UC3, srcBuf);
    Mat srcGRAY(ih, iw, CV_8UC1);
    // color to gray conversion
    cvtColor(srcRGB, srcGRAY, CV_BGR2GRAY);
 
    ROI = Set_ROI(0,0,VPE_OUTPUT_W,VPE_OUTPUT_H);
    ROI_Lane = Set_ROI(0,45 + ROI_Y_OFFSET,VPE_OUTPUT_W, 130+ROI_Y_OFFSET);
    memset(resultBuf, 0, VPE_OUTPUT_W*VPE_OUTPUT_H);
    threshold = 200;
    memcpy(outBuf,srcGRAY.data,VPE_OUTPUT_W*VPE_OUTPUT_H);
    //printf("ROI %d , %d /%d , %d\n",ROI_Lane.left, ROI_Lane.right, ROI_Lane.top, ROI_Lane.bottom);
   // getchar();
    for (y = ROI_Lane.top; y < ROI_Lane.bottom; y++)
    {
        ROI.top = y - 1;
        ROI.bottom = y + 1;
        Projection_V(outBuf, image_size, ROI, projection_v);
        
        //if(y==148) save_projection_data("lane_data.txt",projection_v, VPE_OUTPUT_W);
        Lane_Low_pass_filter(projection_v, lane_lowpass_data, VPE_OUTPUT_W);
        Lane_High_pass_filter(projection_v, lane_highpass_data, VPE_OUTPUT_W);
        Lane_detection_dynamic_threshold(projection_v, lane_filter_data, VPE_OUTPUT_W, lane_offset, 30);
        
        //if(y==148) save_projection_data("lane_filter_data.txt",lane_filter_data, VPE_OUTPUT_W);
        Find_ProjectData_Center_Position(lane_filter_data, VPE_OUTPUT_W, threshold, lane_center_position, &no_lane, lane_pos);
              
//     printf("[%3d]no_lane[%3d]\n",y, no_lane);
      
        if (no_lane >= 3)
        {
//            printf("too many lane[%d]\n\n\n", no_lane);  
        }
    
        for (i = 0; i < no_lane; i++)
        {
            for (j = lane_pos[i].cx; j < lane_pos[i].cy; j++)
            {
                  resultBuf[y*VPE_OUTPUT_W + j] = 255;
            }
 
        }
    }       
}
 
void OpenCV_Land_Calilbration_Result(unsigned char* srcBuf, int iw,int ih, unsigned char* outBuf )
{
    Mat srcRGB(ih, iw, CV_8UC1, srcBuf);
    Mat dstRGB(PERSPECTIVE_IMG_H, PERSPECTIVE_IMG_W, CV_8UC1, outBuf); 
    Mat Matrix;
     
    Point2f Source[4];
     
    Source[0] = Point2f(-40,130+ROI_Y_OFFSET);
    Source[1] = Point2f(680,130+ROI_Y_OFFSET);
    Source[2] = Point2f(110,45+ROI_Y_OFFSET);
    Source[3] = Point2f(530,45+ROI_Y_OFFSET);
     
     
    Point2f Destination[4];
    Destination[0] = Point2f(0,0);
    Destination[1] = Point2f(PERSPECTIVE_IMG_W,0);
    Destination[2] = Point2f(0,PERSPECTIVE_IMG_H);
    Destination[3] = Point2f(PERSPECTIVE_IMG_W,PERSPECTIVE_IMG_H);
    
    // {Point2f(100,0),Point2f(280,0),Point2f(100,240), Point2f(280,240)};
 
    Matrix = getPerspectiveTransform(Source, Destination);
    warpPerspective(srcRGB, dstRGB, Matrix, Size(PERSPECTIVE_IMG_W,PERSPECTIVE_IMG_H));
}
 
void OPenCV_Draw_ROI(unsigned char* srcBuf, int iw, int ih, unsigned char* outBuf, int nw, int nh)
{
     
     // iw:640 , ih: 360
    Scalar lineColor = cv::Scalar(0,255,0);
   
    Mat dstRGB(nh, nw, CV_8UC3, outBuf);    
    Mat srcRGB(ih, iw, CV_8UC3, srcBuf);
    
    cv::Point pt1(0,130+ROI_Y_OFFSET); // A¹ ¹øA° ¿ ¿¡¼ CØ´c ¼±AC ±³A÷A¡  
    cv::Point pt2(640,130+ROI_Y_OFFSET);
    cv::line(srcRGB, pt1, pt2, lineColor, 1); // CI¾a ¼±A¸·I ±×¸®±a
    cv::Point pt3(150,45+ROI_Y_OFFSET);
    cv::Point pt4(490,45+ROI_Y_OFFSET);
    cv::line(srcRGB, pt3, pt4, lineColor, 1); // CI¾a ¼±A¸·I ±×¸®±a
    
    
    cv::line(srcRGB, pt1, pt3, lineColor, 1); // CI¾a ¼±A¸·I ±×¸®±a
    cv::line(srcRGB, pt2, pt4, lineColor, 1); // CI¾a ¼±A¸·I ±×¸®±a
    
    
    cv::resize(srcRGB, dstRGB, cv::Size(nw, nh), 0, 0, CV_INTER_LINEAR);     
}
 
void OpenCV_Perspective_Calibration(unsigned char* srcBuf, int iw,int ih, unsigned char* outBuf )
{
     // cv::line(srcRGB, pt1, pt2, lineColor, 1); // CI¾a ¼±A¸·I ±×¸®±a
    
    Mat srcRGB(ih, iw, CV_8UC3, srcBuf);
    Mat dstRGB(PERSPECTIVE_IMG_H, PERSPECTIVE_IMG_W, CV_8UC3, outBuf); 
    Mat Matrix;
     
    Point2f Source[4];
     
    Source[0] = Point2f(0,130+ROI_Y_OFFSET);
    Source[1] = Point2f(640,130+ROI_Y_OFFSET);
    Source[2] = Point2f(150,45+ROI_Y_OFFSET);
    Source[3] = Point2f(490,45+ROI_Y_OFFSET);
     
     
    Point2f Destination[4];
    Destination[0] = Point2f(0,0);
    Destination[1] = Point2f(PERSPECTIVE_IMG_W,0);
    Destination[2] = Point2f(0,PERSPECTIVE_IMG_H);
    Destination[3] = Point2f(PERSPECTIVE_IMG_W,PERSPECTIVE_IMG_H);
    
    // {Point2f(100,0),Point2f(280,0),Point2f(100,240), Point2f(280,240)};
 
    Matrix = getPerspectiveTransform(Source, Destination);
    warpPerspective(srcRGB, dstRGB, Matrix, Size(PERSPECTIVE_IMG_W,PERSPECTIVE_IMG_H));
}
 
 
 
 
/**
  * @brief  To load image file to the buffer.
  * @param  file: pointer for load image file in local path
             outBuf: destination buffer pointer to load
             nw : width value of the destination buffer
             nh : height value of the destination buffer
  * @retval none
  */
void OpenCV_load_file(char* file, unsigned char* outBuf, int nw, int nh)
{
    Mat srcRGB;
    Mat dstRGB(nh, nw, CV_8UC3, outBuf);
 
    srcRGB = imread(file, CV_LOAD_IMAGE_COLOR); // rgb
    //cvtColor(srcRGB, srcRGB, CV_RGB2BGR);
 
    cv::resize(srcRGB, dstRGB, cv::Size(nw, nh), 0, 0, CV_INTER_LINEAR);
}
 
/**
  * @brief  To convert format from BGR to RGB.
  * @param  inBuf: buffer pointer of BGR image
             w: width value of the buffers
             h : height value of the buffers
             outBuf : buffer pointer of RGB image
  * @retval none
  */
void OpenCV_Bgr2RgbConvert(unsigned char* inBuf, int w, int h, unsigned char* outBuf)
{
    Mat srcRGB(h, w, CV_8UC3, inBuf);
    Mat dstRGB(h, w, CV_8UC3, outBuf);
 
    cvtColor(srcRGB, dstRGB, CV_BGR2RGB);
}
 
/**
  * @brief  Detect faces on loaded image and draw circles on the faces of the loaded image.
  * @param  file: pointer for load image file in local path
             outBuf: buffer pointer to draw circles on the detected faces
             nw : width value of the destination buffer
             nh : height value of the destination buffer
  * @retval none
  */
void OpenCV_face_detection(char* file, unsigned char* outBuf, int nw, int nh)
{
    Mat srcRGB = imread(file, CV_LOAD_IMAGE_COLOR);
    Mat dstRGB(nh, nw, CV_8UC3, outBuf);
    
    // Load Face cascade (.xml file)
    CascadeClassifier face_cascade;
    face_cascade.load( "haarcascade_frontalface_alt.xml" );
 
    // Detect faces
    std::vector<Rect> faces;
    face_cascade.detectMultiScale( srcRGB, faces, 1.1, 2, 0|CV_HAAR_SCALE_IMAGE, Size(30, 30) );
    
    // Draw circles on the detected faces
    for( int i = 0; i < faces.size(); i++ )
    {
        Point center( faces[i].x + faces[i].width*0.5, faces[i].y + faces[i].height*0.5 );
        ellipse( srcRGB, center, Size( faces[i].width*0.5, faces[i].height*0.5), 0, 0, 360, Scalar( 255, 0, 255 ), 4, 8, 0 );
    }
 
    cv::resize(srcRGB, dstRGB, cv::Size(nw, nh), 0, 0, CV_INTER_LINEAR);
}
 
/**
  * @brief  To bind two images on destination buffer.
  * @param  file1: file path of first image to bind
             file2: file path of second image to bind
             outBuf : destination buffer pointer to bind
             nw : width value of the destination buffer
             nh : height value of the destination buffer
  * @retval none
  */
void OpenCV_binding_image(char* file1, char* file2, unsigned char* outBuf, int nw, int nh)
{
    Mat srcRGB = imread(file1, CV_LOAD_IMAGE_COLOR);
    Mat srcRGB2 = imread(file2, CV_LOAD_IMAGE_COLOR);
    Mat dstRGB(nh, nw, CV_8UC3, outBuf);
 
    cv::resize(srcRGB2, srcRGB2, cv::Size(srcRGB2.cols/1.5, srcRGB2.rows/1.5));
    cv::Point location = cv::Point(280, 220);
    for (int y = std::max(location.y, 0); y < srcRGB.rows; ++y)
    {
        int fY = y - location.y;
        if (fY >= srcRGB2.rows)
            break;
        
        for (int x = std::max(location.x, 0); x < srcRGB.cols; ++x)
        {
            int fX = x - location.x;
            if (fX >= srcRGB2.cols)
            break;
            
            double opacity = ((double)srcRGB2.data[fY * srcRGB2.step + fX * srcRGB2.channels() + 3]) / 255.;
            for (int c = 0; opacity > 0 && c < srcRGB.channels(); ++c)
            {
                unsigned char overlayPx = srcRGB2.data[fY * srcRGB2.step + fX * srcRGB2.channels() + c];
                unsigned char srcPx = srcRGB.data[y * srcRGB.step + x * srcRGB.channels() + c];
                srcRGB.data[y * srcRGB.step + srcRGB.channels() * x + c] = srcPx * (1. - opacity) + overlayPx * opacity;
            }
        }
    }
 
    cv::resize(srcRGB, dstRGB, cv::Size(nw, nh), 0, 0, CV_INTER_LINEAR);
}
 
/**
  * @brief  Apply canny edge algorithm and draw it on destination buffer.
  * @param  file: pointer for load image file in local path
             outBuf: destination buffer pointer to apply canny edge
             nw : width value of destination buffer
             nh : height value of destination buffer
  * @retval none
  */
void OpenCV_canny_edge_image(char* file, unsigned char* outBuf, int nw, int nh)
{
    Mat srcRGB = imread(file, CV_LOAD_IMAGE_COLOR);
    Mat srcGRAY;
    Mat dstRGB(nh, nw, CV_8UC3, outBuf);
 
    cvtColor(srcRGB, srcGRAY, CV_BGR2GRAY);
     // AE´I ¾E°i¸®Ao Au¿e
    cv::Mat contours;
    cv::Canny(srcGRAY, // ±×·¹AI·¹º§ ¿μ≫o
        contours, // °a°u ¿U°u¼±
        125,  // ³·Aº °æ°e°ª
        350);  // ³oAº °æ°e°ª
 
    // ³IA|·I E ¼O·I ¿U°u¼±A≫ C￥CoCI¹C·I Eæ¹e °ªA≫ ¹YAu
    //cv::Mat contoursInv; // ¹YAu ¿μ≫o
    //cv::threshold(contours, contoursInv, 128, 255, cv::THRESH_BINARY_INV);
    // ¹a±a °ªAI 128º¸´U AUA¸¸e 255°¡ μCμμ·I ¼³A¤
 
    cvtColor(contours, contours, CV_GRAY2BGR);
    
    cv::resize(contours, dstRGB, cv::Size(nw, nh), 0, 0, CV_INTER_LINEAR);
}
 
/**
  * @brief  Detect the hough and draw hough on destination buffer.
  * @param  srcBuf: source pointer to hough transform
             iw: width value of source buffer
             ih : height value of source buffer
             outBuf : destination pointer to hough transform
             nw : width value of destination buffer
             nh : height value of destination buffer
  * @retval none
  */
void OpenCV_hough_transform(unsigned char* srcBuf, int iw, int ih, unsigned char* outBuf, int nw, int nh)
{
    Scalar lineColor = cv::Scalar(255,255,255);
    
    Mat dstRGB(nh, nw, CV_8UC3, outBuf);
    
    Mat srcRGB(ih, iw, CV_8UC3, srcBuf);
    Mat resRGB(ih, iw, CV_8UC3);
    //cvtColor(srcRGB, srcRGB, CV_BGR2BGRA);
 
    // A³´I ¾E°i¸®Ao Au¿e
    cv::Mat contours;
    cv::Canny(srcRGB, contours, 125, 350);
    
    // ¼± °¨Ao A§CN CaCA º?E?
    std::vector<cv::Vec2f> lines;
    cv::HoughLines(contours, lines, 1, PI/180, // ´U°eº° Aⓒ±a (1°u ￥ð/180¿¡¼ ´U°eº°·I °¡´ECN ¸ðμc °￠μμ·I ¹YAo¸§AC ¼±A≫ A￡A½)
        80);  // AoC￥(vote) AO´e °³¼o
    
    // ¼± ±×¸®±a
    cv::Mat result(contours.rows, contours.cols, CV_8UC3, lineColor);
    //printf("Lines detected: %d\n", lines.size());
 
    // ¼± º¤AI¸| ¹Yº¹CØ ¼± ±×¸®±a
    std::vector<cv::Vec2f>::const_iterator it= lines.begin();
    while (it!=lines.end()) 
    {
        float rho = (*it)[0];   // A¹ ¹øA° ¿a¼O´A rho °A¸®
        float theta = (*it)[1]; // μI ¹øA° ¿a¼O´A μ¨A¸ °￠μμ
        
        if (theta < PI/4. || theta > 3.*PI/4.) // ¼oA÷ Ca
        {
            cv::Point pt1(rho/cos(theta), 0); // A¹ Ca¿¡¼ CØ´c ¼±AC ±³A÷A¡   
            cv::Point pt2((rho-result.rows*sin(theta))/cos(theta), result.rows);
            // ¸¶Ao¸· Ca¿¡¼ CØ´c ¼±AC ±³A÷A¡
            cv::line(srcRGB, pt1, pt2, lineColor, 1); // CI¾a ¼±A¸·I ±×¸®±a
 
        } 
        else // ¼oÆo Ca
        { 
            cv::Point pt1(0,rho/sin(theta)); // A¹ ¹øA° ¿ ¿¡¼ CØ´c ¼±AC ±³A÷A¡  
            cv::Point pt2(result.cols,(rho-result.cols*cos(theta))/sin(theta));
            // ¸¶Ao¸· ¿ ¿¡¼ CØ´c ¼±AC ±³A÷A¡
            cv::line(srcRGB, pt1, pt2, lineColor, 1); // CI¾a ¼±A¸·I ±×¸®±a
        }
        //printf("line: rho=%f, theta=%f\n", rho, theta);
        ++it;
    }
 
    cv::resize(srcRGB, dstRGB, cv::Size(nw, nh), 0, 0, CV_INTER_LINEAR);
}
 
/**
  * @brief  Merge two source images of the same size into the output buffer.
  * @param  src1: pointer to parameter of rgb32 image buffer
             src2: pointer to parameter of bgr32 image buffer
             dst : pointer to parameter of rgb32 output buffer
             w : width of src and dst buffer
             h : height of src and dst buffer
  * @retval none
  */
void OpenCV_merge_image(unsigned char* src1, unsigned char* src2, unsigned char* dst, int w, int h)
{
    Mat src1AR32(h, w, CV_8UC4, src1);
    Mat src2AR32(h, w, CV_8UC4, src2);
    Mat dstAR32(h, w, CV_8UC4, dst);
 
    cvtColor(src2AR32, src2AR32, CV_BGRA2RGBA);
 
    for (int y = 0; y < h; ++y) {
        for (int x = 0; x < w; ++x) {
            double opacity = ((double)(src2AR32.data[y * src2AR32.step + x * src2AR32.channels() + 3])) / 255.;
            for (int c = 0; opacity > 0 && c < src1AR32.channels(); ++c) {
                unsigned char overlayPx = src2AR32.data[y * src2AR32.step + x * src2AR32.channels() + c];
                unsigned char srcPx = src1AR32.data[y * src1AR32.step + x * src1AR32.channels() + c];
                src1AR32.data[y * src1AR32.step + src1AR32.channels() * x + c] = srcPx * (1. - opacity) + overlayPx * opacity;
            }
        }
    }
 
    memcpy(dst, src1AR32.data, w*h*4);
}
 
}
 
-------------------------------------------------------exam_cv.h----------------------------------------------

#define PERSPECTIVE_IMG_W 400
#define PERSPECTIVE_IMG_H 450
#define VPE_OUTPUT_W        640
#define VPE_OUTPUT_H        360
 
#include  "swcar_imageprocessing.h"
 
cRect ROI_Lane_Center_Check[3];
 
#ifndef EXAM_CV_H_
#define EXAM_CV_H_ 
#ifdef __cplusplus
extern "C" {
#endif
 
void OpenCV_load_file(char* file, unsigned char* outBuf, int nw, int nh);
void OpenCV_Bgr2RgbConvert(unsigned char* inBuf, int w, int h, unsigned char* outBuf);
void OpenCV_face_detection(char* file, unsigned char* outBuf, int nw, int nh);
void OpenCV_binding_image(char* file1, char* file2, unsigned char* outBuf, int nw, int nh);
void OpenCV_canny_edge_image(char* file, unsigned char* outBuf, int nw, int nh);
void OpenCV_hough_transform(unsigned char* srcBuf, int iw, int ih, unsigned char* outBuf, int nw, int nh);
void OpenCV_merge_image(unsigned char* src1, unsigned char* src2, unsigned char* dst, int w, int h);
void OpenCV_Perspective_Calibration(unsigned char* srcBuf, int iw,int ih, unsigned char* outBuf );
void OPenCV_Draw_ROI(unsigned char* srcBuf, int iw, int ih, unsigned char* outBuf, int nw, int nh);
void OpenCV_Lane_Detection(unsigned char* srcBuf, int iw,int ih, unsigned char* resultbuf);
 
void OpenCV_grayimage_save_file(char* file, unsigned char* inBuf, int nw, int nh);
void OpenCV_colorimage_save_file(char* file, unsigned char* inBuf, int nw, int nh);
void OpenCV_Land_Calilbration_Result(unsigned char* srcBuf, int iw,int ih, unsigned char* outBuf);
void OpenCV_Lane_YawAngle_Calculation(unsigned char* srcBuf, int iw,int ih);
 
#ifdef __cplusplus
}
#endif
 
#endif //EXAM_CV_H_
 
-------------------------------------------------swcar_imageprocessing.h--------------------------------------------

//

//Threshold(BYTE *Image_Input, BYTE *Image_Output, cSize Image_size, cRect ROI, int threshold, int type);
#define BYTE unsigned char
#define UINT unsigned int
#define m_FORGROUND    255    // Blob시 물체 색깔
#define m_BACKGROUND    0    // Blob시 배경 색깔
#define MAX_NO_BLOB 1000 //최대 blob의 수
#define VPE_OUTPUT_W 640
#define VPE_OUTPUT_H 360

#define PI 3.1415926535897932384626433832795f

#include <stdio.h>
#include <string.h>
#include <math.h>

typedef struct _cPoint
{
    int x;
    int y;
}cPoint;

typedef struct _cSize
{
    int cx;
    int cy;
}cSize;

typedef struct _cRect
{
    int top;
    int bottom;
    int left;
    int right;   
    //int Height;
    //int Width;
}cRect;

typedef struct _cLine_Equ
{
     double a;
     double b;
}cLine_Equ;

void Threshold(unsigned char *Image_Input, unsigned char *Image_Output, cSize image_size, cRect ROI, int threshold, int type);
void Threshold(unsigned char *Image_Input, unsigned char *Image_Output, cSize Image_size, cRect ROI, int threshold, int type);
void Threshold2(BYTE *Image_Input, BYTE *Image_Output,cSize Image_size,cRect ROI, int threshold1,int threshold2);
void Find_Blob_Center(UINT *Label_Result,cSize Image_size,cRect ROI,double *m_center_blob_x,double *m_center_blob_y, int no_blob, unsigned long *area);
long Find_Center(BYTE *Image_Input,cSize Image_size, cRect ROI,double *m_center_x,double *m_center_y, int threshold, int type);
int Blob_Analysis2(BYTE *Binary_Image, unsigned int *Label_Image, cSize image_size,unsigned long min_area,unsigned long max_area);
int Blob_Analysis_ROI(BYTE *Binary_Image, unsigned int *Label_Image, cSize image_size, cRect ROI, unsigned int min_area, unsigned int max_area);
int push(int *stackx, int *stacky, int vx, int vy, int *top,int maxsize);
int pop(int *stackx, int *stacky, int *vx, int *vy, int *top);
void Dilation(BYTE *Input_Image, BYTE *Output_Image,cSize image_size);
void Erode(BYTE *Input_Image, BYTE *Output_Image,cSize image_size);
void Erode_ROI(BYTE *Input_Image, BYTE *Output_Image, cSize image_size,cRect ROI);
void Calculation_Center_BinaryImage(BYTE *Bin_Image, cSize image_size, double *x_c, double *y_c);
void Projection_H(BYTE *In_Image, cSize image_size, cRect ROI, double *projection_h);
void Projection_V(BYTE *In_Image, cSize image_size, cRect ROI, double *projection_v);
void grass(int *projection_temp, BYTE *Label, int size_projection, int i, int no_label);
cRect Set_ROI(int x1,int y1,int x2, int y2);
void Find_ProjectData_Center_Position(double *projection, int size_projection, int threshold, double *position, int *no_pad, cSize* Projection_Blob);
void save_projection_data(char *filename, double *projection, int size_project);

double LinearCurveFitting_H(cPoint* data, int length, double *aa, double *bb);
double LinearCurveFitting_V(cPoint* data, int length, double *cc, double *dd);


void Lane_High_pass_filter(double *in_projection, double *out_projection, int size_projection);
void Lane_Low_pass_filter(double *in_projection, double *out_projection, int size_projection);
void Lane_detection_dynamic_threshold(double *in_projection, double *out_projection, int size_projection, int offset, int  threshold);
-------------------------------------------------car_lib.c--------------------------------------------------------

/*******************************************************************************
 *  INCLUDE FILES
 *******************************************************************************
 */
#include <termios.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/signal.h>
#include <sys/types.h>
#include <time.h>
#include <string.h>
#include <pthread.h>
#include <dlfcn.h>
#include <sys/ioctl.h>
#include <linux/i2c-dev.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "car_lib.h"

/*******************************************************************************
 *  Defines
 *******************************************************************************
 */
//#define BAUDRATE B115200
//#define MODEDEVICE "/dev/ttyS0" // "/dev/ttyS0" is used for debug terminal

#define BAUDRATE        B19200
#define SERIAL_DEVICE   "/dev/ttyS2"  // ttyHS0, ttyHS1, ttyHS3 are available
#define I2C_DEVICE      "/dev/i2c-2"

static int uart_fd;
static int i2c_fd;

/*******************************************************************************
 *  Functions
 *******************************************************************************
 */
void CarControlInit(void)
{
  char fd_serial[20];
  struct termios oldtio, newtio;
 
  char *dev = I2C_DEVICE;
  int addr = 0x4b;
  int r;
 
  // UART configuration
  strcpy(fd_serial, SERIAL_DEVICE); //FFUART
 
  uart_fd = open(fd_serial, O_RDWR | O_NOCTTY );
  if (uart_fd <0) {
    printf("Serial %s  Device Err\n", fd_serial );
    exit(1);
  }
  printf("CarControlInit(void) Uart Device : %s\n", SERIAL_DEVICE);
 
  tcgetattr(uart_fd,&oldtio); /* save current port settings */
  bzero(&newtio, sizeof(newtio));
  newtio.c_cflag = BAUDRATE | CS8 | CLOCAL | CREAD; // | CRTSCTS;
  newtio.c_iflag = IGNPAR;
  newtio.c_oflag = 0;
  newtio.c_lflag = 0;
  newtio.c_cc[VTIME]    = 0;   /* inter-character timer unused */
  newtio.c_cc[VMIN]     = 1;   /* blocking read until 8 chars received */
 
  tcflush(uart_fd, TCIFLUSH);
  tcsetattr(uart_fd,TCSANOW,&newtio);
 
  // I2C configuration
  i2c_fd = open(dev, O_RDWR );
  if(i2c_fd < 0)
  {
    perror("Opening i2c device node\n");
    exit(1);
  }
 
  r = ioctl(i2c_fd, I2C_SLAVE, addr);
  if(r < 0)
  {
    perror("Selecting i2c device\n");
  }
}

void CarLight_Write(char status)
{
    unsigned char buf[8];

    buf[0] = 0xa0;
    if(status == ALL_ON)
    {
        buf[1] = 0x03; //code length (1) + 2
        buf[2] = 0x01; //write(1)
        buf[3] = ALL_ON;    // all on = 3
        buf[4] = 0xa7; //checksum = a0 + 03 + 01 + 03
   
        printf("Front and Rear Light ON\n");
    }
    else if(status == FRONT_ON)
    {
        buf[1] = 0x03; //code length (1) + 2
        buf[2] = 0x01; //write(1)
        buf[3] = FRONT_ON;    // front on = 1
        buf[4] = 0xa5; //checksum = a0 + 03 + 01 + 01
               
        printf("Front Light ON\n");
    }
    else if(status == REAR_ON)
    {
        buf[1] = 0x03; //code length (1) + 2
        buf[2] = 0x01; //write(1)
        buf[3] = REAR_ON;    // rear on = 2
        buf[4] = 0xa6; //checksum = a0 + 03 + 01 + 02
               
        printf("Rear Light ON\n");
    }
    else
    {
        buf[1] = 0x03; //code length (1) + 2
        buf[2] = 0x01; //write(1)
        buf[3] = ALL_OFF;    // all off = 0
        buf[4] = 0xa4; //checksum = a0 + 03 + 01 + 00
       
        printf("Front and Rear Light OFF\n");
    }
    write(uart_fd, &buf[0], 5);
}

void Alarm_Write(char status)
{
    unsigned char buf[8];

    buf[0] = 0xa2;
    if(status == ON)
    {
        buf[1] = 0x03; //code length (1) + 2
        buf[2] = 0x01; //write(1)
        buf[3] = 0x64; //0.01s (1sec = 100 = 0x64)
        buf[4] = 0x0a; //checksum = a2 + 03 + 01 + 64 = 10a
       
        printf("Alarm ON\n");
    }
    else
    {
        buf[1] = 0x03; //code length (1) + 2
        buf[2] = 0x01; //write(1)
        buf[3] = 0x00; //0.00s
        buf[4] = 0xa6; //checksum = a2 + 03 + 01 + 00
       
        printf("Alarm OFF\n");
    }
    write(uart_fd, &buf[0], 5);
}

void Winker_Write(char status)
{
    unsigned char buf[8];

    buf[0] = 0xa1;
    if(status == ALL_ON)
    {
        buf[1] = 0x03; //code length (1) + 2
        buf[2] = 0x01; //write(1)
        buf[3] = ALL_ON;    // all on = 3
        buf[4] = 0xa8; //checksum = a1 + 03 + 01 + 03
   
        printf("Left and Right Winker ON\n");
    }
    else if(status == RIGHT_ON)
    {
        buf[1] = 0x03; //code length (1) + 2
        buf[2] = 0x01; //write(1)
        buf[3] = RIGHT_ON;    // right on = 1
        buf[4] = 0xa6; //checksum = a1 + 03 + 01 + 01
               
        printf("Right Winker ON\n");
    }
    else if(status == LEFT_ON)
    {
        buf[1] = 0x03; //code length (1) + 2
        buf[2] = 0x01; //write(1)
        buf[3] = LEFT_ON;    // left on = 2
        buf[4] = 0xa7; //checksum = a1 + 03 + 01 + 02
               
        printf("Left Winker ON\n");
    }
    else
    {
        buf[1] = 0x03; //code length (1) + 2
        buf[2] = 0x01; //write(1)
        buf[3] = ALL_OFF;    // all off = 0
        buf[4] = 0xa5; //checksum = a1 + 03 + 01 + 00
       
        printf("Left and Right Winker OFF\n");
    }
    write(uart_fd, &buf[0], 5);
}

char SpeedControlOnOff_Read(void)
{
    unsigned char buf[8];
    unsigned char read_buf[8];

    buf[0] = 0x90;
    buf[1] = 0x02; //code length (0) + 2
    buf[2] = 0x02; //read(2)
    buf[3] = 0x94; //checksum = 90 + 02 + 02
   
    //  printf("Read Speed Control OnOff\n");
    write(uart_fd, &buf[0], 4);
    read(uart_fd, &read_buf[0], 4);

    return read_buf[2];
}

void SpeedControlOnOff_Write(char status)
{
    unsigned char buf[8];

    buf[0] = 0x90;
    buf[1] = 0x03; //code length (1) + 2
    buf[2] = 0x01; //write(1)
    buf[3] = status; //UNCONTROL=0 CONTROL=1
    buf[4] = 0x94 + buf[3]; //checksum = 90 + 03 + 01 + buf[3]
   
    //printf("SpeedControlOnOff_Write(void) = %d\n", buf[3]);
    write(uart_fd, &buf[0], 5);
}

signed short DesireSpeed_Read(void)
{
    unsigned char buf[8];
    unsigned char read_buf[8];

    buf[0] = 0x91;
    buf[1] = 0x02; //code length (0) + 2
    buf[2] = 0x02; //read(2)
    buf[3] = 0x95; //checksum = 91 + 02 + 02
   
//  printf("Read Desire Speed\n");
    write(uart_fd, &buf[0], 4);
    read(uart_fd, &read_buf[0], 5);

    return ((signed short)(read_buf[3]<<8) + (signed short)(read_buf[2]));
}

void DesireSpeed_Write(signed short speed)
{
    unsigned char buf[8];

    buf[0] = 0x91;
    buf[1] = 0x04; //code length (2) + 2
    buf[2] = 0x01; //write(1)
    buf[3] = speed & 0x00ff; //bottom byte
    buf[4] = (speed >> 8) & 0x00ff; //top byte
    buf[5] = 0x96 + buf[3] + buf[4]; //checksum
   
    //printf("DesireSpeed_Write(void) = %d\n", speed);
    write(uart_fd, &buf[0], 6);
}

unsigned char SpeedPIDProportional_Read(void)
{
    unsigned char buf[8];
    unsigned char read_buf[8];

    buf[0] = 0x92;
    buf[1] = 0x02; //code length (0) + 2
    buf[2] = 0x02; //read(2)
    buf[3] = 0x96; //checksum = 92 + 02 + 02
   
//  printf("Read Speed PID Proportional\n");
    write(uart_fd, &buf[0], 4);
    read(uart_fd, &read_buf[0], 4);

    return read_buf[2];
}

void SpeedPIDProportional_Write(unsigned char gain)
{
    unsigned char buf[8];

    buf[0] = 0x92;
    buf[1] = 0x03; //code length (1) + 2
    buf[2] = 0x01; //write(1)
    buf[3] = gain;
    buf[4] = 0x96 + buf[3]; //checksum = 90 + 03 + 01 + buf[3]
   
    printf("SpeedPIDProportional_WriteH = %d\n", buf[3]);
    write(uart_fd, &buf[0], 5);
}

unsigned char SpeedPIDIntegral_Read(void)
{
    unsigned char buf[8];
    unsigned char read_buf[8];

    buf[0] = 0x93;
    buf[1] = 0x02; //code length (0) + 2
    buf[2] = 0x02; //read(2)
    buf[3] = 0x97; //checksum = 93 + 02 + 02
   
//  printf("Read Speed PID Integral\n");
    write(uart_fd, &buf[0], 4);
    read(uart_fd, &read_buf[0], 4);

    return read_buf[2];
}

void SpeedPIDIntegral_Write(unsigned char gain)
{
    unsigned char buf[8];

    buf[0] = 0x93;
    buf[1] = 0x03; //code length (1) + 2
    buf[2] = 0x01; //write(1)
    buf[3] = gain;
    buf[4] = 0x97 + buf[3]; //checksum = 93 + 03 + 01 + buf[3]
   
    printf("SpeedPIDIntegral_Write(void) = %d\n", buf[3]);
    write(uart_fd, &buf[0], 5);
}

unsigned char SpeedPIDDifferential_Read(void)
{
    unsigned char buf[8];
    unsigned char read_buf[8];

    buf[0] = 0x94;
    buf[1] = 0x02; //code length (0) + 2
    buf[2] = 0x02; //read(2)
    buf[3] = 0x98; //checksum = 94 + 02 + 02
   
//  printf("Read Speed PID Differential\n");
    write(uart_fd, &buf[0], 4);
    read(uart_fd, &read_buf[0], 4);

    return read_buf[2];
}

void SpeedPIDDifferential_Write(unsigned char gain)
{
    unsigned char buf[8];

    buf[0] = 0x94;
    buf[1] = 0x03; //code length (1) + 2
    buf[2] = 0x01; //write(1)
    buf[3] = gain;
    buf[4] = 0x98 + buf[3]; //checksum = 94 + 03 + 01 + buf[3]
   
    printf("SpeedPIDDifferential_Write(void) = %d\n", buf[3]);
    write(uart_fd, &buf[0], 5);
}

char PositionControlOnOff_Read(void)
{
    unsigned char buf[8];
    unsigned char read_buf[8];

    buf[0] = 0x96;
    buf[1] = 0x02; //code length (0) + 2
    buf[2] = 0x02; //read(2)
    buf[3] = 0x9a; //checksum = 96 + 02 + 02
   
//  printf("Read Position Control OnOff\n");
    write(uart_fd, &buf[0], 4);
    read(uart_fd, &read_buf[0], 4);

    return read_buf[2];
   
}

void PositionControlOnOff_Write(char status)
{
    unsigned char buf[8];

    buf[0] = 0x96;
    buf[1] = 0x03; //code length (1) + 2
    buf[2] = 0x01; //write(1)
    buf[3] = status; //UNCONTROL=0 CONTROL=1
    buf[4] = 0x9a + buf[3]; //checksum = 9a + 03 + 01 + buf[3]
   
    printf("PositionControlOnOff_Write(void) = %d\n", buf[3]);
    write(uart_fd, &buf[0], 5);
}

unsigned char PositionProportionPoint_Read(void)
{
    unsigned char buf[8];
    unsigned char read_buf[8];

    buf[0] = 0x98;
    buf[1] = 0x02; //code length (0) + 2
    buf[2] = 0x02; //read(2)
    buf[3] = 0x9c; //checksum = 98 + 02 + 02
   
//  printf("Read Position Proportion Point\n");
    write(uart_fd, &buf[0], 4);
    read(uart_fd, &read_buf[0], 4);

    return read_buf[2];
}

void PositionProportionPoint_Write(unsigned char gain)
{
    unsigned char buf[8];

    buf[0] = 0x98;
    buf[1] = 0x03; //code length (1) + 2
    buf[2] = 0x01; //write(1)
    buf[3] = gain;
    buf[4] = 0x9c + buf[3]; //checksum = 98 + 03 + 01 + buf[3]
   
    printf("PositionProportionPoint_Write(void) = %d\n", buf[3]);
    write(uart_fd, &buf[0], 5);
}

signed int DesireEncoderCount_Read(void)
{
    unsigned char buf[8];
    unsigned char read_buf[8];

    buf[0] = 0x97;
    buf[1] = 0x02; //code length (0) + 2
    buf[2] = 0x02; //read(2)
    buf[3] = 0x9b; //checksum = 97 + 02 + 02
   
//  printf("Read Desire position\n");
    write(uart_fd, &buf[0], 4);
    read(uart_fd, &read_buf[0], 7);
   
    return ((signed int)(read_buf[5]<<24) + (signed int)(read_buf[4]<<16) + (signed int)(read_buf[3]<<8) + (signed int)(read_buf[2]));
}

void DesireEncoderCount_Write(signed int position)
{
    unsigned char buf[8];

    buf[0] = 0x97;
    buf[1] = 0x06; //code length (6) + 2
    buf[2] = 0x01; //write(1)
    buf[3] = position & 0x000000ff; //bottom byte
    buf[4] = (position >> 8) & 0x000000ff; //3rd byte
    buf[5] = (position >> 16) & 0x000000ff; //2nd byte
    buf[6] = (position >> 24) & 0x000000ff; //top byte
    buf[7] = 0x9e + buf[3] + buf[4] + buf[5] + buf[6]; //checksum

    //printf("DesireEncoderCount_Write(void) = %d\n", position);
    write(uart_fd, &buf[0], 8);
}

signed int EncoderCounter_Read(void)
{
    unsigned char buf[8];
    unsigned char read_buf[8];

    buf[0] = 0xb0;
    buf[1] = 0x02; //code length (0) + 2
    buf[2] = 0x02; //read(2)
    buf[3] = 0xb4; //checksum = b0 + 02 + 02
   
//  printf("Read Encoder Counter\n");
    write(uart_fd, &buf[0], 4);
    read(uart_fd, &read_buf[0], 7);
   
    return ((signed int)(read_buf[5]<<24) + (signed int)(read_buf[4]<<16) + (signed int)(read_buf[3]<<8) + (signed int)(read_buf[2]));
}

void EncoderCounter_Write(signed int position)
{
    unsigned char buf[8];

    buf[0] = 0xb0;
    buf[1] = 0x06; //code length (6) + 2
    buf[2] = 0x01; //write(1)
    buf[3] = position & 0x000000ff; //bottom byte
    buf[4] = (position >> 8) & 0x000000ff; //3rd byte
    buf[5] = (position >> 16) & 0x000000ff; //2nd byte
    buf[6] = (position >> 24) & 0x000000ff; //top byte
    buf[7] = 0xb7 + buf[3] + buf[4] + buf[5] + buf[6]; //checksum

    //printf("EncoderCounter_Write(void) = %d\n", position);
    write(uart_fd, &buf[0], 8);
}

signed short SteeringServoControl_Read(void)
{
    unsigned char buf[8];
    unsigned char read_buf[8];

    buf[0] = 0xa3;
    buf[1] = 0x02; //code length (0) + 2
    buf[2] = 0x02; //read(2)
    buf[3] = 0xa7; //checksum = a3 + 02 + 02
   
//  printf("Read Steering Servo Angle\n");
    write(uart_fd, &buf[0], 4);
    read(uart_fd, &read_buf[0], 5);

    return ((signed short)(read_buf[3]<<8) + (signed short)(read_buf[2]));
}

void SteeringServoControl_Write(signed short angle)
{
    unsigned char buf[8];

    buf[0] = 0xa3;
    buf[1] = 0x04; //code length (2) + 2
    buf[2] = 0x01; //write(1)
    buf[3] = angle & 0x00ff; //bottom byte
    buf[4] = (angle >> 8) & 0x00ff; //top byte
    buf[5] = 0xa8 + buf[3] + buf[4]; //checksum
   
    //printf("SteeringServoControl_Write(void) = %d\n", angle);
    write(uart_fd, &buf[0], 6);
}

signed short CameraXServoControl_Read(void)
{
    unsigned char buf[8];
    unsigned char read_buf[8];

    buf[0] = 0xa5;
    buf[1] = 0x02; //code length (0) + 2
    buf[2] = 0x02; //read(2)
    buf[3] = 0xa9; //checksum = a5 + 02 + 02
   
//  printf("Read Camera X Servo Angle\n");
    write(uart_fd, &buf[0], 4);
    read(uart_fd, &read_buf[0], 5);

    return ((signed short)(read_buf[3]<<8) + (signed short)(read_buf[2]));
}

void CameraXServoControl_Write(signed short angle)
{
    unsigned char buf[8];

    buf[0] = 0xa5;
    buf[1] = 0x04; //code length (2) + 2
    buf[2] = 0x01; //write(1)
    buf[3] = angle & 0x00ff; //bottom byte
    buf[4] = (angle >> 8) & 0x00ff; //top byte
    buf[5] = 0xaa + buf[3] + buf[4]; //checksum
   
    //printf("CameraXServoControl_Write(void) = %d\n", angle);
    write(uart_fd, &buf[0], 6);
}

signed short CameraYServoControl_Read(void)
{
    unsigned char buf[8];
    unsigned char read_buf[8];

    buf[0] = 0xa7;
    buf[1] = 0x02; //code length (0) + 2
    buf[2] = 0x02; //read(2)
    buf[3] = 0xab; //checksum = a7 + 02 + 02
   
//  printf("Read Camera Y Angle\n");
    write(uart_fd, &buf[0], 4);
    read(uart_fd, &read_buf[0], 5);

    return ((signed short)(read_buf[3]<<8) + (signed short)(read_buf[2]));
}

void CameraYServoControl_Write(signed short angle)
{
    unsigned char buf[8];

    buf[0] = 0xa7;
    buf[1] = 0x04; //code length (2) + 2
    buf[2] = 0x01; //write(1)
    buf[3] = angle & 0x00ff; //bottom byte
    buf[4] = (angle >> 8) & 0x00ff; //top byte
    buf[5] = 0xac + buf[3] + buf[4]; //checksum
   
    //printf("CameraYServoControl_Write(void) = %d\n", angle);
    write(uart_fd, &buf[0], 6);
}

unsigned char LineSensor_Read(void)
{
    unsigned char buf[8];
    unsigned char read_buf[8];

    buf[0] = 0xb1;
    buf[1] = 0x02; //code length (0) + 2
    buf[2] = 0x02; //read(2)
    buf[3] = 0xb5; //checksum = b1 + 02 + 02
   
//  printf("Read Line Trace Sensor\n");
    write(uart_fd, &buf[0], 4);
    read(uart_fd, &read_buf[0], 4);

    return read_buf[2];
}

int DistanceSensor(int channel)
{
    unsigned char buf[8];
    unsigned char command;
    unsigned char value[2];
    useconds_t delay = 2000;
    int data;
    int r;

    switch(channel)
    {
    case 1 : command = 0x8c; break;
    case 2 : command = 0xcc; break;
    case 3 : command = 0x9c; break;
    case 4 : command = 0xdc; break;
    case 5 : command = 0xac; break;
    case 6 : command = 0xec; break;
    default : printf("channel error.\n"); break;
    }
    r = write(i2c_fd, &command, 1);
    usleep(delay);

    r = read(i2c_fd, value, 2);
    if(r != 2)
    {
        perror("reading i2c device\n");
    }
    usleep(delay);
        
    data = (int)((value[0] & 0b00001111)<<8)+value[1];

    return data;
}


float distance_sensor(int ad_value)
{
    float temp;
    float distance;
    temp = ad_value ;
    distance =  19475.78 * pow(temp, -1);
   
    return distance;
}
-----------------------------------car_lib.h----------------------------------------

#ifndef _PARAM_HANDLE_
#define _PARAM_HANDLE_

#ifdef __cplusplus
extern "C" {
#endif

/*******************************************************************************
 *  Defines
 *******************************************************************************
 */
#define OFF         0x00
#define ON          0xFF

// Light
#define ALL_OFF     0x00
#define REAR_ON     0x02
#define FRONT_ON    0x01
#define ALL_ON      0x03
#define RIGHT_ON    0x01
#define LEFT_ON     0x02

// Speed and position controller setting
#define UNCONTROL   0x00
#define CONTROL     0x01

/*******************************************************************************
 *  Functions
 *******************************************************************************
 */
void CarControlInit(void);
void CarLight_Write(char status);
void Alarm_Write(char status);
void Winker_Write(char status);
char SpeedControlOnOff_Read(void);
void SpeedControlOnOff_Write(char status);
signed short DesireSpeed_Read(void);
void DesireSpeed_Write(signed short speed);
unsigned char SpeedPIDProportional_Read(void);
void SpeedPIDProportional_Write(unsigned char gain);
unsigned char SpeedPIDIntegral_Read(void);
void SpeedPIDIntegral_Write(unsigned char gain);
unsigned char SpeedPIDDifferential_Read(void);
void SpeedPIDDifferential_Write(unsigned char gain);
char PositionControlOnOff_Read(void);
void PositionControlOnOff_Write(char status);
unsigned char PositionProportionPoint_Read(void);
void PositionProportionPoint_Write(unsigned char gain);
signed int DesireEncoderCount_Read(void);
void DesireEncoderCount_Write(signed int position);
signed int EncoderCounter_Read(void);
void EncoderCounter_Write(signed int position);
signed short SteeringServoControl_Read(void);
void SteeringServoControl_Write(signed short angle);
signed short CameraXServoControl_Read(void);
void CameraXServoControl_Write(signed short angle);
signed short CameraYServoControl_Read(void);
void CameraYServoControl_Write(signed short angle);
unsigned char LineSensor_Read(void);
int DistanceSensor(int channel);
float distance_sensor(int ad_value);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif

---------------------------------util.h----------------------------------------

/*
 * Copyright (C) 2011 Texas Instruments
 * Author: Rob Clark <rob.clark@linaro.org>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published by
 * the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef UTIL_H_
#define UTIL_H_

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <assert.h>

#include "list.h"

#define FOURCC(a, b, c, d) ((uint32_t)(uint8_t)(a) | ((uint32_t)(uint8_t)(b) << 8) | ((uint32_t)(uint8_t)(c) << 16) | ((uint32_t)(uint8_t)(d) << 24 ))
#define FOURCC_STR(str)    FOURCC(str[0], str[1], str[2], str[3])

/* Dynamic debug. */
#define DBG(fmt, ...) \
        do { if (debug) fprintf(stderr, fmt "\n", ##__VA_ARGS__); } while (0)

#define MSG(fmt, ...) \
        do { fprintf(stderr, fmt "\n", ##__VA_ARGS__); } while (0)
#define ERROR(fmt, ...) \
        do { fprintf(stderr, "ERROR:%s:%d: " fmt "\n", __func__, __LINE__, ##__VA_ARGS__); } while (0)

#ifndef container_of
#define container_of(ptr, type, member) \
    (type *)((char *)(ptr) - (char *) &((type *)0)->member)
#endif

#ifndef MIN
#  define MIN(a,b)     (((a) < (b)) ? (a) : (b))
#endif

#ifndef MAX
#  define MAX(a,b)     (((a) > (b)) ? (a) : (b))
#endif

#ifndef PAGE_SHIFT
#  define PAGE_SHIFT 12
#endif

#ifndef PAGE_SIZE
#  define PAGE_SIZE (1 << PAGE_SHIFT)
#endif

/* align x to next highest multiple of 2^n */
#define ALIGN2(x,n)   (((x) + ((1 << (n)) - 1)) & ~((1 << (n)) - 1))

/* Display Interface:
 *
 * Could be either KMS or X11 depending on build and
 * environment.  Some of details of opening/connecting, allocating buffers,
 * etc, differ.  The intention is just to provide as simple as possible
 * abstraction to avoid lots of duplication in each test app to handle
 * both cases.
 */

struct buffer {
    uint32_t fourcc, width, height;
    int nbo;
    struct omap_bo *bo[4];
    uint32_t pitches[4];
    struct list unlocked;
    bool multiplanar;   /* True when Y and U/V are in separate buffers. */
    int fd[4];          /* dmabuf */
    bool noScale;
};

/* Other utilities..
 */
extern int debug;

/* State variables, used to maintain the playback rate. */
struct rate_control {
    int fps;        /* When > zero, we maintain playback rate. */
    long last_frame_mark;   /* The time when the last frame was displayed,
                 * as returned by the mark() function. */
    int usecs_to_sleep; /* Number of useconds we have slep last frame. */
};

int check_args(int argc, char **argv);
void maintain_playback_rate(struct rate_control *p);

#include <sys/time.h>
static inline long
mark(long *last)
{
    struct timeval t;
    gettimeofday(&t, NULL);
    if (last) {
        long delta = t.tv_usec - *last;

        /* Handle the case, where the seconds have changed.
         * TODO: keep the whole timeval struct, to be able to cope with
         * more than one second deltas? */
        if (t.tv_usec < *last)
            delta += 1000000;

        *last = t.tv_usec;
        return delta;
    }
    return t.tv_usec;
}
#endif /* UTIL_H_ */
-------------------------------------------------display-kms.c-------------------------------------------

/*
 * Copyright (C) 2011 Texas Instruments
 * Author: Rob Clark <rob.clark@linaro.org>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published by
 * the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "util.h"
#include "display-kms.h"

#include <xf86drmMode.h>
#include <drm.h>


/* NOTE: healthy dose of recycling from libdrm modetest app.. */

/*
 * Mode setting with the kernel interfaces is a bit of a chore.
 * First you have to find the connector in question and make sure the
 * requested mode is available.
 * Then you need to find the encoder attached to that connector so you
 * can bind it with a free crtc.
 */
struct connector {
    uint32_t id;
    char mode_str[64];
    drmModeModeInfo *mode;
    drmModeEncoder *encoder;
    int crtc;
    int pipe;
};

#define to_display_kms(x) container_of(x, struct display_kms, base)
struct display_kms {
    struct display base;

    uint32_t connectors_count;
    struct connector connector[10];
    drmModePlane *ovr[10];

    int scheduled_flips, completed_flips;
    uint32_t bo_flags;
    drmModeResPtr resources;
    drmModePlaneRes *plane_resources;
    struct buffer *current;
    bool no_master;
    int mastership;
};

#define to_buffer_kms(x) container_of(x, struct buffer_kms, base)
struct buffer_kms {
    struct buffer base;
    uint32_t fb_id;
};

static int global_fd = 0;
static uint32_t used_planes = 0;
static int ndisplays = 0;

static struct omap_bo *
alloc_bo(struct display *disp, uint32_t bpp, uint32_t width, uint32_t height,
        uint32_t *bo_handle, uint32_t *pitch)
{
    struct display_kms *disp_kms = to_display_kms(disp);
    struct omap_bo *bo;
    uint32_t bo_flags = disp_kms->bo_flags;

    if ((bo_flags & OMAP_BO_TILED) == OMAP_BO_TILED) {
        bo_flags &= ~OMAP_BO_TILED;
        if (bpp == 8) {
            bo_flags |= OMAP_BO_TILED_8;
        } else if (bpp == 16) {
            bo_flags |= OMAP_BO_TILED_16;
        } else if (bpp == 32) {
            bo_flags |= OMAP_BO_TILED_32;
        }
    }
    bo_flags |= OMAP_BO_WC;

    if (bo_flags & OMAP_BO_TILED) {
        bo = omap_bo_new_tiled(disp->dev, ALIGN2(width,7), height, bo_flags);
    } else {
        bo = omap_bo_new(disp->dev, width * height * bpp / 8, bo_flags);
    }

    if (bo) {
        *bo_handle = omap_bo_handle(bo);
        *pitch = width * bpp / 8;
        if (bo_flags & OMAP_BO_TILED)
            *pitch = ALIGN2(*pitch, PAGE_SHIFT);
    }

    return bo;
}

struct buffer *
alloc_buffer(struct display *disp, uint32_t fourcc, uint32_t w, uint32_t h, bool addfb)
{
    struct buffer_kms *buf_kms;
    struct buffer *buf;
    uint32_t bo_handles[4] = {0}, offsets[4] = {0};
    int ret;

    buf_kms = calloc(1, sizeof(*buf_kms));
    if (!buf_kms) {
        ERROR("allocation failed");
        return NULL;
    }
    buf = &buf_kms->base;

    buf->fourcc = fourcc;
    buf->width = w;
    buf->height = h;
    buf->multiplanar = true;

    buf->nbo = 1;
    buf->noScale = false; // full disp

    if (!fourcc)
        fourcc = FOURCC('A','R','2','4');

    if(fourcc == FOURCC('R', 'G', 'B', '3') || fourcc == FOURCC('B', 'G', 'R', '3'))
        fourcc = FOURCC('R','G','2','4');

    if(fourcc == FOURCC('R', 'G', 'B', '4'))
       fourcc = FOURCC('A','R','2','4');

    switch(fourcc) {
    case FOURCC('R','G','2','4'):
    case FOURCC('B','G','2','4'):
        buf->nbo = 1;
        buf->bo[0] = alloc_bo(disp, 24, buf->width, buf->height,
                &bo_handles[0], &buf->pitches[0]);
        break;

    case FOURCC('A','R','2','4'):
    case FOURCC('R','A','2','4'):
        buf->nbo = 1;
        buf->bo[0] = alloc_bo(disp, 32, buf->width, buf->height,
                &bo_handles[0], &buf->pitches[0]);
        break;
    case FOURCC('U','Y','V','Y'):
    case FOURCC('Y','U','Y','V'):
        buf->nbo = 1;
        buf->bo[0] = alloc_bo(disp, 16, buf->width, buf->height,
                &bo_handles[0], &buf->pitches[0]);
        break;
    case FOURCC('N','V','1','2'):
        if (disp->multiplanar) {
            buf->nbo = 2;
            buf->bo[0] = alloc_bo(disp, 8, buf->width, buf->height,
                    &bo_handles[0], &buf->pitches[0]);
            buf->fd[0] = omap_bo_dmabuf(buf->bo[0]);
            buf->bo[1] = alloc_bo(disp, 16, buf->width/2, buf->height/2,
                    &bo_handles[1], &buf->pitches[1]);
            buf->fd[1] = omap_bo_dmabuf(buf->bo[1]);
        } else {
            buf->nbo = 1;
            buf->bo[0] = alloc_bo(disp, 8, buf->width, buf->height * 3 / 2,
                    &bo_handles[0], &buf->pitches[0]);
            buf->fd[0] = omap_bo_dmabuf(buf->bo[0]);
            bo_handles[1] = bo_handles[0];
            buf->pitches[1] = buf->pitches[0];
            offsets[1] = buf->width * buf->height;
            buf->multiplanar = false;
        }
        break;
    case FOURCC('I','4','2','0'):
        buf->nbo = 3;
        buf->bo[0] = alloc_bo(disp, 8, buf->width, buf->height,
                &bo_handles[0], &buf->pitches[0]);
        buf->bo[1] = alloc_bo(disp, 8, buf->width/2, buf->height/2,
                &bo_handles[1], &buf->pitches[1]);
        buf->bo[2] = alloc_bo(disp, 8, buf->width/2, buf->height/2,
                &bo_handles[2], &buf->pitches[2]);
        break;
    default:
        ERROR("invalid format: 0x%08x", fourcc);
        goto fail;
    }

    if(addfb) {
        ret = drmModeAddFB2(disp->fd, buf->width, buf->height, fourcc,
                bo_handles, buf->pitches, offsets, &buf_kms->fb_id, 0);
        if (ret) {
            ERROR("drmModeAddFB2 failed: %s (%d)", strerror(errno), ret);
            goto fail;
        }
    }
    return buf;

fail:
    // XXX cleanup
    return NULL;
}

void
free_buffers(struct display *disp, uint32_t n)
{
    uint32_t i;
    for (i = 0; i < n; i++) {
        if (disp->buf[i]) {
            close(disp->buf[i]->fd[0]);
            omap_bo_del(disp->buf[i]->bo[0]);
            if(disp->multiplanar){
                close(disp->buf[i]->fd[1]);
                omap_bo_del(disp->buf[i]->bo[1]);
            }
        }
    }
    free(disp->buf);
}

static struct buffer **
alloc_buffers(struct display *disp, uint32_t n,
        uint32_t fourcc, uint32_t w, uint32_t h)
{
    struct buffer **bufs;
    uint32_t i = 0;

    bufs = calloc(n, sizeof(*bufs));
    if (!bufs) {
        ERROR("allocation failed");
        goto fail;
    }

    for (i = 0; i < n; i++) {
        bufs[i] = alloc_buffer(disp, fourcc, w, h, true);
        if (!bufs[i]) {
            ERROR("allocation failed");
            goto fail;
        }
    }
    disp->buf=bufs;
    return bufs;

fail:
    // XXX cleanup
    return NULL;
}

static struct buffer **
get_buffers(struct display *disp, uint32_t n)
{
    return alloc_buffers(disp, n, 0, disp->width, disp->height);
}

static struct buffer **
get_vid_buffers(struct display *disp, uint32_t n,
        uint32_t fourcc, uint32_t w, uint32_t h)
{
    return alloc_buffers(disp, n, fourcc, w, h);
}

static void
page_flip_handler(int fd, unsigned int frame,
        unsigned int sec, unsigned int usec, void *data)
{
    struct display *disp = data;
    struct display_kms *disp_kms = to_display_kms(disp);

    disp_kms->completed_flips++;

    MSG("Page flip: frame=%d, sec=%d, usec=%d, remaining=%d", frame, sec, usec,
            disp_kms->scheduled_flips - disp_kms->completed_flips);
}

static int
post_buffer(struct display *disp, struct buffer *buf)
{
    struct display_kms *disp_kms = to_display_kms(disp);
    struct buffer_kms *buf_kms = to_buffer_kms(buf);
    int ret, last_err = 0, x = 0;
    uint32_t i;

    for (i = 0; i < disp_kms->connectors_count; i++) {
        struct connector *connector = &disp_kms->connector[i];

        if (! connector->mode) {
            continue;
        }

        if (! disp_kms->current) {
            /* first buffer we flip to, setup the mode (since this can't
             * be done earlier without a buffer to scanout)
             */
            MSG("Setting mode %s on connector %d, crtc %d",
                    connector->mode_str, connector->id, connector->crtc);

            ret = drmModeSetCrtc(disp->fd, connector->crtc, buf_kms->fb_id,
                    x, 0, &connector->id, 1, connector->mode);

            x += connector->mode->hdisplay;
        } else {
            ret = drmModePageFlip(disp->fd, connector->crtc, buf_kms->fb_id,
                    DRM_MODE_PAGE_FLIP_EVENT, disp);
            disp_kms->scheduled_flips++;
        }

        if (ret) {
            ERROR("Could not post buffer on crtc %d: %s (%d)",
                    connector->crtc, strerror(errno), ret);
            last_err = ret;
            /* well, keep trying the reset of the connectors.. */
        }
    }

    /* if we flipped, wait for all flips to complete! */
    while (disp_kms->scheduled_flips > disp_kms->completed_flips) {
        drmEventContext evctx = {
                .version = DRM_EVENT_CONTEXT_VERSION,
                .page_flip_handler = page_flip_handler,
        };
        struct timeval timeout = {
                .tv_sec = 3,
                .tv_usec = 0,
        };
        fd_set fds;

        FD_ZERO(&fds);
        FD_SET(disp->fd, &fds);

        ret = select(disp->fd + 1, &fds, NULL, NULL, &timeout);
        if (ret <= 0) {
            if (errno == EAGAIN) {
                continue;    /* keep going */
            } else {
                ERROR("Timeout waiting for flip complete: %s (%d)",
                        strerror(errno), ret);
                last_err = ret;
                break;
            }
        }

        drmHandleEvent(disp->fd, &evctx);
    }

    disp_kms->current = buf;

    return last_err;
}

#if 0
int
get_overlay_plane(struct display *disp, struct buffer *buf)
{
    struct display_kms *disp_kms = to_display_kms(disp);
    uint32_t i, ret;

    for (i = 0; i < disp_kms->connectors_count; i++) {
        struct connector *connector = &disp_kms->connector[i];
        drmModeModeInfo *mode = connector->mode;

        disp_kms->ovr[i] = drmModeGetPlane(disp->fd,
                    disp_kms->plane_resources->planes[1]);

        ret = drmModeObjectSetProperty(disp->fd,
            disp_kms->ovr[i]->plane_id, DRM_MODE_OBJECT_PLANE, 7, 3);
        if (ret < 0) {
            MSG("Could not set Z order for plane");
            return ret;
        }
    }
    return 0;
}
#endif

static int
post_vid_buffer(struct display *disp, struct buffer *buf,
        uint32_t x, uint32_t y, uint32_t w, uint32_t h)
{
    struct display_kms *disp_kms = to_display_kms(disp);
    struct buffer_kms *buf_kms = to_buffer_kms(buf);
    int ret = 0;
    uint32_t i, j;

    /* ensure we have the overlay setup: */
    for (i = 0; i < disp_kms->connectors_count; i++) {
        struct connector *connector = &disp_kms->connector[i];
        drmModeModeInfo *mode = connector->mode;

        if (! mode) {
            continue;
        }

        if (! disp_kms->ovr[i]) {

            for (j = 0; j < disp_kms->plane_resources->count_planes; j++) {
                if (used_planes & (1 << j)) {
                    continue;
                }
                drmModePlane *ovr = drmModeGetPlane(disp->fd,
                        disp_kms->plane_resources->planes[j]);
                if (ovr->possible_crtcs & (1 << connector->pipe)) {
                    disp_kms->ovr[i] = ovr;
                    used_planes |= (1 << j);
                    break;
                }
            }
        }

        if (! disp_kms->ovr[i]) {
            MSG("Could not find plane for crtc %d", connector->crtc);
            ret = -1;
            /* carry on and see if we can find at least one usable plane */
            continue;
        }

        if(buf->noScale) {
            ret = drmModeSetPlane(disp->fd, disp_kms->ovr[i]->plane_id,
                connector->crtc, buf_kms->fb_id, 0,
                /* Use x and y as co-ordinates of overlay */
                x, y, buf->width, buf->height,
                /* Consider source x and y is 0 always */
                0, 0, w << 16, h << 16);
        } else {
            ret = drmModeSetPlane(disp->fd, disp_kms->ovr[i]->plane_id,
                connector->crtc, buf_kms->fb_id, 0,
                /* make video fullscreen: */
                0, 0, mode->hdisplay, mode->vdisplay,
                /* source/cropping coordinates are given in Q16 */
                x << 16, y << 16, w << 16, h << 16);
        }

        if (ret) {
            ERROR("failed to enable plane %d: %s",
                    disp_kms->ovr[i]->plane_id, strerror(errno));
        }
    }

    if (disp_kms->no_master && disp_kms->mastership) {
        /* Drop mastership after the first buffer on each plane is
         * displayed. This will lock these planes for us and allow
         * others to consume remaining
         */
        disp_kms->mastership = 0;
        drmDropMaster(disp->fd);
    }

    return ret;
}

static void
close_kms(struct display *disp)
{
    struct display_kms *disp_kms = to_display_kms(disp);

    omap_device_del(disp->dev);
    disp->dev = NULL;
    if (used_planes) {
        used_planes >>= 1;
    }
    if (--ndisplays == 0) {
        close(global_fd);
    }

    free(disp_kms);
    disp = NULL;
}

static void
connector_find_mode(struct display *disp, struct connector *c)
{
    struct display_kms *disp_kms = to_display_kms(disp);
    drmModeConnector *connector;
    int i, j;

    /* First, find the connector & mode */
    c->mode = NULL;
    for (i = 0; i < disp_kms->resources->count_connectors; i++) {
        connector = drmModeGetConnector(disp->fd,
                disp_kms->resources->connectors[i]);

        if (!connector) {
            ERROR("could not get connector %i: %s",
                    disp_kms->resources->connectors[i], strerror(errno));
            drmModeFreeConnector(connector);
            continue;
        }

        if (!connector->count_modes) {
            drmModeFreeConnector(connector);
            continue;
        }

        if (connector->connector_id != c->id) {
            drmModeFreeConnector(connector);
            continue;
        }

        for (j = 0; j < connector->count_modes; j++) {
            c->mode = &connector->modes[j];
            if (!strcmp(c->mode->name, c->mode_str))
                break;
        }

        /* Found it, break out */
        if (c->mode)
            break;

        drmModeFreeConnector(connector);
    }

    if (!c->mode) {
        ERROR("failed to find mode \"%s\"", c->mode_str);
        return;
    }

    /* Now get the encoder */
    for (i = 0; i < disp_kms->resources->count_encoders; i++) {
        c->encoder = drmModeGetEncoder(disp->fd,
                disp_kms->resources->encoders[i]);

        if (!c->encoder) {
            ERROR("could not get encoder %i: %s",
                    disp_kms->resources->encoders[i], strerror(errno));
            drmModeFreeEncoder(c->encoder);
            continue;
        }

        if (c->encoder->encoder_id  == connector->encoder_id)
            break;

        drmModeFreeEncoder(c->encoder);
    }

    if (c->crtc == -1)
        c->crtc = c->encoder->crtc_id;

    /* and figure out which crtc index it is: */
    for (i = 0; i < disp_kms->resources->count_crtcs; i++) {
        if (c->crtc == (int)disp_kms->resources->crtcs[i]) {
            c->pipe = i;
            break;
        }
    }
}

void
disp_kms_usage(void)
{
    MSG("KMS Display Options:");
    MSG("\t-1 \t\tforce single-plane buffers");
    MSG("\t-t <tiled-mode>\t8, 16, 32, or auto");
    MSG("\t-s <connector_id>:<mode>\tset a mode");
    MSG("\t-s <connector_id>@<crtc_id>:<mode>\tset a mode");
}

struct display *
disp_kms_open(int argc, char **argv)
{
    struct display_kms *disp_kms = NULL;
    struct display *disp;
    int i;

    disp_kms = calloc(1, sizeof(*disp_kms));
    if (!disp_kms) {
        ERROR("allocation failed");
        goto fail;
    }
    disp = &disp_kms->base;

    if (!global_fd) {
        global_fd = drmOpen("omapdrm", NULL);
        if (global_fd < 0) {
            ERROR("could not open drm device: %s (%d)", strerror(errno), errno);
            goto fail;
        }
    }

    disp->fd = global_fd;
    ndisplays++;  /* increment the number of displays counter */

    disp->dev = omap_device_new(disp->fd);
    if (!disp->dev) {
        ERROR("couldn't create device");
        goto fail;
    }

    disp->get_buffers = get_buffers;
    disp->get_vid_buffers = get_vid_buffers;
    disp->post_buffer = post_buffer;
    disp->post_vid_buffer = post_vid_buffer;
    disp->close = close_kms;
    disp->disp_free_buf = free_buffers ;
    disp_kms->resources = drmModeGetResources(disp->fd);
    if (!disp_kms->resources) {
        ERROR("drmModeGetResources failed: %s", strerror(errno));
        goto fail;
    }

    disp_kms->plane_resources = drmModeGetPlaneResources(disp->fd);
    if (!disp_kms->plane_resources) {
        ERROR("drmModeGetPlaneResources failed: %s", strerror(errno));
        goto fail;
    }

    disp->multiplanar = true;

    /* note: set args to NULL after we've parsed them so other modules know
     * that it is already parsed (since the arg parsing is decentralized)
     */
    for (i = 1; i < argc; i++) {
        if (!argv[i]) {
            continue;
        }
        if (!strcmp("-1", argv[i])) {
            disp->multiplanar = false;
        } else if (!strcmp("-t", argv[i])) {
            int n;
            argv[i++] = NULL;
            if (!strcmp(argv[i], "auto")) {
                n = 0;
            } else if (sscanf(argv[i], "%d", &n) != 1) {
                ERROR("invalid arg: %s", argv[i]);
                goto fail;
            }

            disp_kms->bo_flags &= ~OMAP_BO_TILED;

            if (n == 8) {
                disp_kms->bo_flags |= OMAP_BO_TILED_8;
            } else if (n == 16) {
                disp_kms->bo_flags |= OMAP_BO_TILED_16;
            } else if (n == 32) {
                disp_kms->bo_flags |= OMAP_BO_TILED_32;
            } else if (n == 0) {
                disp_kms->bo_flags |= OMAP_BO_TILED;
            } else {
                ERROR("invalid arg: %s", argv[i]);
                goto fail;
            }
        } else if (!strcmp("-s", argv[i])) {
            struct connector *connector =
                    &disp_kms->connector[disp_kms->connectors_count++];
            connector->crtc = -1;
            argv[i++] = NULL;
            if (sscanf(argv[i], "%d:%64s",
                   &connector->id,
                   connector->mode_str) != 2 &&
                sscanf(argv[i], "%d@%d:%64s",
                   &connector->id,
                   &connector->crtc,
                   connector->mode_str) != 3) {
                // TODO: we could support connector specified as a name too, I suppose
                ERROR("invalid arg: %s", argv[i]);
                goto fail;
            }
            disp_kms->bo_flags |= OMAP_BO_SCANOUT;
        } else if (!strcmp("-nm", argv[i])) {
            disp_kms->no_master = true;
            disp_kms->mastership = 1;
        } else {
            /* ignore */
            continue;
        }
        argv[i] = NULL;
    }

    disp->width = 0;
    disp->height = 0;
    for (i = 0; i < (int)disp_kms->connectors_count; i++) {
        struct connector *c = &disp_kms->connector[i];
        connector_find_mode(disp, c);
        if (c->mode == NULL)
            continue;
        /* setup side-by-side virtual display */
        disp->width += c->mode->hdisplay;
        if (disp->height < c->mode->vdisplay) {
            disp->height = c->mode->vdisplay;
        }
    }

    disp->overlay_p.id = 20;
    disp->overlay_p.z_val = 3; // Range: 0 to 3 lowest value for bottom
    disp->overlay_p.glo_alp = 255;//150; // 255 : transparency 0.
    disp->overlay_p.pre_mul_alp = 0;

    MSG("display : using %d connectors, %dx%d",
            disp_kms->connectors_count, disp->width, disp->height);

    return disp;

fail:
    // XXX cleanup
    return NULL;
}


void disp_kms_usage(void);
struct display * disp_kms_open(int argc, char **argv);

#ifdef HAVE_X11
void disp_x11_usage(void);
struct display * disp_x11_open(int argc, char **argv);
void disp_x11_close(struct display *disp);
#endif

#ifdef HAVE_KMSCUBE
void disp_kmscube_usage(void);
struct display * disp_kmscube_open(int argc, char **argv);
#endif

#ifdef HAVE_WAYLAND
void disp_wayland_usage(void);
struct display *disp_wayland_open(int argc, char **argv);
#endif

void
disp_usage(void)
{
    MSG("Generic Display options:");
    MSG("\t--debug\tTurn on debug messages.");
    MSG("\t--fps <fps>\tforce playback rate (0 means \"do not force\")");
    MSG("\t--no-post\tDo not post buffers (disables screen updates) for benchmarking. Rate can still be controlled.");

#ifdef HAVE_X11
    disp_x11_usage();
#endif
#ifdef HAVE_KMSCUBE
    disp_kmscube_usage();
#endif
#ifdef HAVE_WAYLAND
    disp_wayland_usage();
#endif
    disp_kms_usage();
}

static int
empty_post_buffer(struct display *disp, struct buffer *buf)
{
    return 0;
}

static int
empty_post_vid_buffer(struct display *disp, struct buffer *buf,
            uint32_t x, uint32_t y, uint32_t w, uint32_t h)
{
    return 0;
}

struct display *
disp_open(int argc, char **argv)
{
    struct display *disp;
    int i, fps = 0, no_post = 0;

    for (i = 1; i < argc; i++) {
        if (!argv[i]) {
            continue;
        }
        if (!strcmp("--debug", argv[i])) {
            debug = 1;
            MSG("Enabling dynamic debug.");
            argv[i] = NULL;

        } else if (!strcmp("--fps", argv[i])) {
            argv[i++] = NULL;

            if (sscanf(argv[i], "%d", &fps) != 1) {
                ERROR("invalid arg: %s", argv[i]);
                return NULL;
            }

            MSG("Forcing playback rate at %d fps.", fps);
            argv[i] = NULL;

        } else if (!strcmp("--no-post", argv[i])) {
            MSG("Disabling buffers posting.");
            no_post = 1;
            argv[i] = NULL;
        }
    }

#ifdef HAVE_X11
    disp = disp_x11_open(argc, argv);
    if (disp)
        goto out;
#endif
#ifdef HAVE_KMSCUBE
    disp = disp_kmscube_open(argc, argv);
    if (disp)
        goto out;
#endif
#ifdef HAVE_WAYLAND
    disp = disp_wayland_open(argc, argv);
    if (disp)
        goto out;
#endif

    disp = disp_kms_open(argc, argv);

    if (!disp) {
        ERROR("unable to create display");
        return NULL;
    }

out:
    disp->rtctl.fps = fps;

    /* If buffer posting is disabled from command line, override post
     * functions with empty ones. */
    if (no_post) {
        disp->post_buffer = empty_post_buffer;
        disp->post_vid_buffer = empty_post_vid_buffer;
    }

    return disp;
}

struct buffer **
disp_get_vid_buffers(struct display *disp, uint32_t n,
        uint32_t fourcc, uint32_t w, uint32_t h)
{
    struct buffer **buffers;
    unsigned int i;

    buffers = disp->get_vid_buffers(disp, n, fourcc, w, h);
    if (buffers) {
        /* if allocation succeeded, store in the unlocked
         * video buffer list
         */
        list_init(&disp->unlocked);
        for (i = 0; i < n; i++)
            list_add(&buffers[i]->unlocked, &disp->unlocked);
    }

    return buffers;
}

void
disp_free_buffers(struct display *disp, uint32_t n)
{
        disp->disp_free_buf(disp, n);
}

struct buffer *
disp_get_vid_buffer(struct display *disp)
{
    struct buffer *buf = NULL;
    if (!list_is_empty(&disp->unlocked)) {
        buf = list_last_entry(&disp->unlocked, struct buffer, unlocked);
        list_del(&buf->unlocked);

        /* barrier.. if we are using GPU blitting, we need to make sure
         * that the GPU is finished:
         */
        omap_bo_cpu_prep(buf->bo[0], OMAP_GEM_WRITE);
        omap_bo_cpu_fini(buf->bo[0], OMAP_GEM_WRITE);
    }
    return buf;
}

void
disp_put_vid_buffer(struct display *disp, struct buffer *buf)
{
    list_add(&buf->unlocked, &disp->unlocked);
}

/* flip to / post the specified buffer */
int
disp_post_buffer(struct display *disp, struct buffer *buf)
{
    int ret;

    ret = disp->post_buffer(disp, buf);
    if(!ret)
        maintain_playback_rate(&disp->rtctl);
    return ret;
}

/* flip to / post the specified video buffer */
int
disp_post_vid_buffer(struct display *disp, struct buffer *buf,
        uint32_t x, uint32_t y, uint32_t w, uint32_t h)
{
    int ret;

    ret = disp->post_vid_buffer(disp, buf, x, y, w, h);
    if(!ret)
        maintain_playback_rate(&disp->rtctl);
    return ret;
}

struct buffer *
disp_get_fb(struct display *disp)
{
    struct buffer **bufs = disp_get_buffers(disp, 1);
    if (!bufs)
        return NULL;
    fill(bufs[0], 42);
    disp_post_buffer(disp, bufs[0]);
    return bufs[0];
}


/* stolen from modetest.c */
static void
fillRGB4(char *virtual, int n, int width, int height, int stride)
{
    int i, j;
    /* paint the buffer with colored tiles */
    for (j = 0; j < height; j++) {
        uint32_t *fb_ptr = (uint32_t*)((char*)virtual + j * stride);
        for (i = 0; i < width; i++) {
            div_t d = div(n+i+j, width);
            fb_ptr[i] =
                    0x00130502 * (d.quot >> 6) +
                    0x000a1120 * (d.rem >> 6);
        }
    }
}


/* swap these for big endian.. */
#define RED   2
#define GREEN 1
#define BLUE  0

static void
fill420(unsigned char *y, unsigned char *u, unsigned char *v,
        int cs /*chroma pixel stride */,
        int n, int width, int height, int stride)
{
    int i, j;

    /* paint the buffer with colored tiles, in blocks of 2x2 */
    for (j = 0; j < height; j+=2) {
        unsigned char *y1p = y + j * stride;
        unsigned char *y2p = y1p + stride;
        unsigned char *up = u + (j/2) * stride * cs / 2;
        unsigned char *vp = v + (j/2) * stride * cs / 2;

        for (i = 0; i < width; i+=2) {
            div_t d = div(n+i+j, width);
            uint32_t rgb = 0x00130502 * (d.quot >> 6) + 0x000a1120 * (d.rem >> 6);
            unsigned char *rgbp = (unsigned char *)&rgb;
            unsigned char y = (0.299 * rgbp[RED]) + (0.587 * rgbp[GREEN]) + (0.114 * rgbp[BLUE]);

            *(y2p++) = *(y1p++) = y;
            *(y2p++) = *(y1p++) = y;

            *up = (rgbp[BLUE] - y) * 0.565 + 128;
            *vp = (rgbp[RED] - y) * 0.713 + 128;
            up += cs;
            vp += cs;
        }
    }
}

static void
fill422(unsigned char *virtual, int n, int width, int height, int stride)
{
    int i, j;
    /* paint the buffer with colored tiles */
    for (j = 0; j < height; j++) {
        uint8_t *ptr = (uint8_t*)((char*)virtual + j * stride);
        for (i = 0; i < width; i++) {
            div_t d = div(n+i+j, width);
            uint32_t rgb = 0x00130502 * (d.quot >> 6) + 0x000a1120 * (d.rem >> 6);
            unsigned char *rgbp = (unsigned char *)&rgb;
            unsigned char y = (0.299 * rgbp[RED]) + (0.587 * rgbp[GREEN]) + (0.114 * rgbp[BLUE]);

            *(ptr++) = y;
            *(ptr++) = (rgbp[BLUE] - y) * 0.565 + 128;
            *(ptr++) = y;
            *(ptr++) = (rgbp[RED] - y) * 0.713 + 128;
        }
    }
}


void
fill(struct buffer *buf, int n)
{
    int i;

    for (i = 0; i < buf->nbo; i++)
        omap_bo_cpu_prep(buf->bo[i], OMAP_GEM_WRITE);

    switch(buf->fourcc) {
    case 0: {
        assert(buf->nbo == 1);
        fillRGB4(omap_bo_map(buf->bo[0]), n,
                buf->width, buf->height, buf->pitches[0]);
        break;
    }
    case FOURCC('Y','U','Y','V'): {
        assert(buf->nbo == 1);
        fill422(omap_bo_map(buf->bo[0]), n,
                buf->width, buf->height, buf->pitches[0]);
        break;
    }
    case FOURCC('N','V','1','2'): {
        unsigned char *y, *u, *v;
        assert(buf->nbo == 2);
        y = omap_bo_map(buf->bo[0]);
        u = omap_bo_map(buf->bo[1]);
        v = u + 1;
        fill420(y, u, v, 2, n, buf->width, buf->height, buf->pitches[0]);
        break;
    }
    case FOURCC('I','4','2','0'): {
        unsigned char *y, *u, *v;
        assert(buf->nbo == 3);
        y = omap_bo_map(buf->bo[0]);
        u = omap_bo_map(buf->bo[1]);
        v = omap_bo_map(buf->bo[2]);
        fill420(y, u, v, 1, n, buf->width, buf->height, buf->pitches[0]);
        break;
    }
    default:
        ERROR("invalid format: 0x%08x", buf->fourcc);
        break;
    }

    for (i = 0; i < buf->nbo; i++)
        omap_bo_cpu_fini(buf->bo[i], OMAP_GEM_WRITE);
}


/**
  * @brief  Set z-order property of plane
                Range: 0 to 3
                lowest value for bottom
                highest value for top
  * @param  disp: pointer to parameter of display
                 plane_id : id of plane
  * @retval none
  */
void set_z_order(struct display *disp, uint32_t plane_id)
{
    uint32_t i, val;

    if (plane_id == disp->overlay_p.id)
        val = disp->overlay_p.z_val;
    else
        val = 0;

    DBG("z-order plane_id:%d, val:%d\n", plane_id, val);

    i = drmModeObjectSetProperty(disp->fd, plane_id,
                     DRM_MODE_OBJECT_PLANE, 7, val);
    if (i < 0) {
        ERROR("set z-order for plane id %d failed!!\n", plane_id);
    }
}

/**
  * @brief  Set alpha property of plane
                 Global alpha range: 0 to 255
                 0 - fully transparent
                 127 - semi transparent
                 255 - fully opaque
  * @param  disp: pointer to parameter of display
                 plane_id : id of plane
  * @retval none
  */
void set_global_alpha(struct display *disp, uint32_t plane_id)
{
    uint32_t i, val;

    if (plane_id == disp->overlay_p.id)
        val = disp->overlay_p.glo_alp;
    else
        val = 127;// - semi transparent

    DBG("set_global_alpha plane_id:%d, val:%d\n", plane_id, val);

    i = drmModeObjectSetProperty(disp->fd, plane_id,
                     DRM_MODE_OBJECT_PLANE, 8, val);
    if (i < 0) {
        ERROR("set global alpha for plane id %d failed\n", plane_id);
    }
}

/**
  * @brief  Set multipled alpha property of plane
                 Pre multipled alpha value: 0 or 1
                 0 - source is not premultiply with alpha
                 1 - source is premultiply with alpha
  * @param  disp: pointer to parameter of display
                 plane_id : id of plane
  * @retval none
  */
void set_pre_multiplied_alpha(struct display *disp, uint32_t plane_id)
{
    uint32_t i, val;

    if (plane_id == disp->overlay_p.id)
        val = disp->overlay_p.pre_mul_alp;
    else
        val = 0;

    i = drmModeObjectSetProperty(disp->fd, plane_id,
                     DRM_MODE_OBJECT_PLANE, 9, val);
    if (i < 0) {
        ERROR("set pre multiply alpha for plane id %d failed\n",
              plane_id);
    }
}

/**
  * @brief  Alloc overlay buffer and a new buffer object
  * @param  disp: pointer to parameter of struct display
                 fourcc : format of overlay buffer
                 x : x position of overlay
                 y : y position of overlay
                 w : width of overlay
                 h : height of overlay
  * @retval  none
  */
void alloc_overlay_plane(struct display *disp, uint32_t fourcc, int x, int y, int w, int h)
{
    /* Position of overlay window:(0,0) for top left corner,
       change value if you want to place it somewhere.
    */
    disp->overlay_p.x = x;
    disp->overlay_p.y = y;

    /* Size to be displayed on lcd */
    disp->overlay_p.xres = w;
    disp->overlay_p.yres = h;

    disp->overlay_p_bo = alloc_buffer(disp, fourcc, w, h, true);
    disp->overlay_p_bo->noScale = true;

    if (!disp->overlay_p_bo) {
        ERROR("create test buffer for plane1 failed\n");
    }

    DBG("set_plane1\n");
}

/**
  * @brief  Free overlay buffer and destroy a buffer object
  * @param  disp: pointer to parameter of struct display
  * @retval  none
  */
void free_overlay_plane(struct display *disp)
{
    close(disp->overlay_p_bo->fd[0]);
    omap_bo_del(disp->overlay_p_bo->bo[0]);
}

/**
  * @brief  Update overlay buffer
  * @param  disp: pointer to parameter of struct display
  * @retval  none
  */
void update_overlay_disp(struct display *disp)
{
    struct display_kms *disp_kms = to_display_kms(disp);
    struct connector *c = &disp_kms->connector[0];
    struct buffer_kms *buf_kms = to_buffer_kms(disp->overlay_p_bo);
    struct plane* pplane = &disp->overlay_p;
    uint32_t flags = 0;

    if(disp->overlay_p_bo->noScale) {
        if (drmModeSetPlane(disp->fd, pplane->id,
                            c->crtc, buf_kms->fb_id, flags,
                            pplane->x, pplane->y, pplane->xres, pplane->yres,
                            0, 0, pplane->xres << 16, pplane->yres << 16)) {
            ERROR("failed to update overlay (noscale)\n");
        }
    } else {
        if(drmModeSetPlane(disp->fd, pplane->id,
                            c->crtc, buf_kms->fb_id, flags,
                            0, 0, c->mode->hdisplay, c->mode->vdisplay,
                            pplane->x << 16, pplane->y << 16, pplane->xres << 16, pplane->yres << 16)) {
            ERROR("failed to update overlay (scale)\n");
        }
    }
}

/**
  * @brief  Get frame buffer pointer for direct access
  * @param  buf: pointer to parameter of struct buffer
                 ppfbuf: pointer to parameter of framebuffer
  * @retval  if success, return 0 value
  */
int get_framebuf(struct buffer *buf, unsigned char** ppfbuf)
{
    int ret = 0;

    if(buf == NULL || ppfbuf == NULL) {
        ERROR("Invalid param\n");
        return -1;
    }

    if(buf->nbo == 1) {
        ppfbuf[0] = (unsigned char*)omap_bo_map(buf->bo[0]);
        if(ppfbuf[0] == NULL)
            ret = -1;
    } else if(buf->nbo == 2) {
        ppfbuf[0] = (unsigned char*)omap_bo_map(buf->bo[0]);
        ppfbuf[1] = (unsigned char*)omap_bo_map(buf->bo[1]);
        if(ppfbuf[0] == NULL || ppfbuf[1] == NULL)
            ret = -1;
    } else {
        MSG("[%s] not yet support (nbo:%d, format: %.4s)\n", __func__, buf->nbo, (char*)&buf->fourcc);
        return -1;
    }

    return ret;
}

---------------------------------------------------vpe-common.h-------------------------------------------------

#ifndef VPE_COMMON_H_
#define VPE_COMMON_H_
 
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <string.h>
 
#include "display-kms.h"
#include "util.h"
 
#define NUMBUF                          6
 
struct image_params {
    int width;
    int height;
    int fourcc;
    int size;
    int size_uv;
    int coplanar;
    enum v4l2_colorspace colorspace;
    int numbuf;
};
 
struct vpe {
    int fd;
    int field;
    int deint;
    int translen;
    struct image_params src;
    struct image_params dst;
    struct v4l2_crop crop;
    int input_buf_dmafd[NUMBUF];
    int input_buf_dmafd_uv[NUMBUF];
    int output_buf_dmafd[NUMBUF];
    int output_buf_dmafd_uv[NUMBUF];
    struct display *disp;
    struct buffer **disp_bufs;
};
 
struct vpe *vpe_open(void);
int vpe_close(struct vpe *vpe);
int describeFormat (char *format, struct image_params *image);
int vpe_input_init(struct vpe *vpe);
int vpe_output_init(struct vpe *vpe);
int vpe_input_qbuf(struct vpe *vpe, int index);
int vpe_output_qbuf(struct vpe *vpe, int index);
int vpe_stream_on(int fd, int type);
int vpe_stream_off(int fd, int type);
int vpe_input_dqbuf(struct vpe *vpe);
int vpe_output_dqbuf(struct vpe *vpe);
void vpe_output_fullscreen(struct vpe* vpe, bool bfull);
 
#endif // VPE_COMMON_H_
 
-------------------------------------vpe-common.c------------------------------------------------

/*
 *  Copyright (c) 2013-2014, Texas Instruments Incorporated
 *  Author: alaganraj <alaganraj.s@ti.com>
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  *  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *  *  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  *  Neither the name of Texas Instruments Incorporated nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 *  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 *  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 *  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *  Contact information for paper mail:
 *  Texas Instruments
 *  Post Office Box 655303
 *  Dallas, Texas 75265
 *  Contact information:
 *  http://www-k.ext.ti.com/sc/technical-support/product-information-centers.htm?
 *  DCMP=TIHomeTracking&HQS=Other+OT+home_d_contact
 *  ============================================================================
 *
 */
 
/*
 * @File        vpe-common.c
 * @Brief       vpe specific common functions, used to integrate vpe 
 *      with other modules.
 *
 *      Input buffer must be allocated in application, queue it to vpe 
 *      by passing buffer index
 *      
 *      Output buffer allocated in vpe_output_init() as vpe output intended
 *      to display on LCD.
 */
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <string.h>
#include <errno.h>
 
#include <linux/videodev2.h>
#include <linux/v4l2-controls.h>
 
#include <sys/mman.h>
#include <sys/ioctl.h>
 
#include <xf86drm.h>
#include <omap_drm.h>
#include <omap_drmif.h>
 
#include "util.h"
#include "vpe-common.h"
 
 
#define pexit(fmt, arg...) { \
        printf(fmt, ## arg); \
        exit(1); \
}
 
#define V4L2_CID_TRANS_NUM_BUFS         (V4L2_CID_PRIVATE_BASE)
 
 
//#define vpe_debug
 
#ifdef vpe_debug
#define dprintf(fmt, arg...) printf(fmt, ## arg)
#else
#define dprintf(fmt, arg...) do {} while(0)
#endif
 
/**
 *****************************************************************************
 * @brief:  open the device
 *
 * @return: vpe  struct vpe pointer 
 *****************************************************************************
*/
struct vpe *vpe_open(void)
{
    char devname[20] = "/dev/video0";
    struct vpe *vpe;
 
    vpe = calloc(1, sizeof(*vpe));
 
    vpe->fd =  open(devname, O_RDWR);
    if(vpe->fd < 0) {
            pexit("Cant open %s\n", devname);
            free(vpe);
            vpe = NULL;
    }
    return vpe;
}
 
/**
 *****************************************************************************
 * @brief:  close the device and free memory
 *
 * @param:  vpe  struct vpe pointer
 *
 * @return: 0 on success 
 *****************************************************************************
*/
int vpe_close(struct vpe *vpe)
{
    close(vpe->fd);
    free(vpe);
    
    return 0;
}
 
/**
 *****************************************************************************
 * @brief:  fills 4cc, size, coplanar, colorspace based on command line input 
 *
 * @param:  format  char pointer
 * @param:  image  struct image_params pointer
 *
 * @return: 0 on success 
 *****************************************************************************
*/
int describeFormat (char *format, struct image_params *image)
{
        image->size   = -1;
        image->fourcc = -1;
        if (strcmp (format, "rgb24") == 0) {
                image->fourcc = V4L2_PIX_FMT_RGB24;
                image->size = image->height * image->width * 3;
                image->coplanar = 0;
                image->colorspace = V4L2_COLORSPACE_SRGB;
 
        } else if (strcmp (format, "bgr24") == 0) {
                image->fourcc = V4L2_PIX_FMT_BGR24;
                image->size = image->height * image->width * 3;
                image->coplanar = 0;
                image->colorspace = V4L2_COLORSPACE_SRGB;
 
        } else if (strcmp (format, "argb32") == 0) {
                image->fourcc = V4L2_PIX_FMT_RGB32;
                image->size = image->height * image->width * 4;
                image->coplanar = 0;
                image->colorspace = V4L2_COLORSPACE_SRGB;
 
        } else if (strcmp (format, "abgr32") == 0) {
                image->fourcc = V4L2_PIX_FMT_BGR32;
                image->size = image->height * image->width * 4;
                image->coplanar = 0;
                image->colorspace = V4L2_COLORSPACE_SRGB;
 
        } else if (strcmp (format, "yuv444") == 0) {
                image->fourcc = V4L2_PIX_FMT_YUV444;
                image->size = image->height * image->width * 3;
                image->coplanar = 0;
                image->colorspace = V4L2_COLORSPACE_SMPTE170M;
 
        } else if (strcmp (format, "yvyu") == 0) {
                image->fourcc = V4L2_PIX_FMT_YVYU;
                image->size = image->height * image->width * 2;
                image->coplanar = 0;
                image->colorspace = V4L2_COLORSPACE_SMPTE170M;
 
        } else if (strcmp (format, "yuyv") == 0) {
                image->fourcc = V4L2_PIX_FMT_YUYV;
                image->size = image->height * image->width * 2;
                image->coplanar = 0;
                image->colorspace = V4L2_COLORSPACE_SMPTE170M;
 
        } else if (strcmp (format, "uyvy") == 0) {
                image->fourcc = V4L2_PIX_FMT_UYVY;
                image->size = image->height * image->width * 2;
                image->coplanar = 0;
                image->colorspace = V4L2_COLORSPACE_SMPTE170M;
 
        } else if (strcmp (format, "vyuy") == 0) {
                image->fourcc = V4L2_PIX_FMT_VYUY;
                image->size = image->height * image->width * 2;
                image->coplanar = 0;
                image->colorspace = V4L2_COLORSPACE_SMPTE170M;
 
        } else if (strcmp (format, "nv16") == 0) {
                image->fourcc = V4L2_PIX_FMT_NV16;
                image->size = image->height * image->width * 2;
                image->coplanar = 0;
                image->colorspace = V4L2_COLORSPACE_SMPTE170M;
 
        } else if (strcmp (format, "nv61") == 0) {
                image->fourcc = V4L2_PIX_FMT_NV61;
                image->size = image->height * image->width * 2;
                image->coplanar = 0;
                image->colorspace = V4L2_COLORSPACE_SMPTE170M;
 
        } else if (strcmp (format, "nv12") == 0) {
                image->fourcc = V4L2_PIX_FMT_NV12;
                image->size = image->height * image->width * 1.5;
                image->coplanar = 1;
                image->colorspace = V4L2_COLORSPACE_SMPTE170M;
 
        } else if (strcmp (format, "nv21") == 0) {
                image->fourcc = V4L2_PIX_FMT_NV21;
                image->size = image->height * image->width * 1.5;
                image->coplanar = 1;
                image->colorspace = V4L2_COLORSPACE_SMPTE170M;
 
        } else {
                return 0;
 
        }
 
        return 1;
}
 
/**
 *****************************************************************************
 * @brief:  sets crop parameters 
 *
 * @param:  vpe  struct vpe pointer
 *
 * @return: 0 on success 
 *****************************************************************************
*/
static int set_crop(struct vpe *vpe)
{
    int ret = 0;
    
    if ((vpe->crop.c.top == 0) && (vpe->crop.c.left == 0) &&
        (vpe->crop.c.width == 0) && (vpe->crop.c.height == 0)) {
        dprintf("setting default crop params\n");
        vpe->crop.c.top = 0;
        vpe->crop.c.left = 0;
        vpe->crop.c.width = vpe->src.width;
        vpe->crop.c.height = vpe->src.height;
        vpe->crop.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
    }
 
    ret = ioctl(vpe->fd, VIDIOC_S_CROP, &vpe->crop);
    if (ret < 0)
        pexit("error setting crop\n");
    
    return 0;
}
 
/**
 *****************************************************************************
 * @brief:  sets control, howmany jobs to be handled on multi instance 
 *
 * @param:  vpe  struct vpe pointer
 *
 * @return: 0 on success 
 *****************************************************************************
*/
static int set_ctrl(struct vpe *vpe)
{
    int ret;
    struct  v4l2_control ctrl;
 
    memset(&ctrl, 0, sizeof(ctrl));
    ctrl.id = V4L2_CID_TRANS_NUM_BUFS;
    ctrl.value = vpe->translen;
    ret = ioctl(vpe->fd, VIDIOC_S_CTRL, &ctrl);
    if (ret < 0)
        pexit("vpe: S_CTRL failed\n");
    
    return 0;
}
 
/**
 *****************************************************************************
 * @brief:  Intialize the vpe input by calling set_control, set_format,
 *      set_crop, refbuf ioctls
 *
 * @param:  vpe  struct vpe pointer
 *
 * @return: 0 on success 
 *****************************************************************************
*/
int vpe_input_init(struct vpe *vpe)
{
    int ret;
    struct v4l2_format fmt;
    struct v4l2_requestbuffers rqbufs;
 
    set_ctrl(vpe);
        
    memset(&fmt, 0, sizeof fmt);
    fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
 
    ret = ioctl(vpe->fd, VIDIOC_G_FMT, &fmt);
    if (ret < 0)
        pexit( "vpe i/p: G_FMT_1 failed: %s\n", strerror(errno));
 
    fmt.fmt.pix_mp.width = vpe->src.width;
    fmt.fmt.pix_mp.height = vpe->src.height;
    fmt.fmt.pix_mp.pixelformat = vpe->src.fourcc;
    fmt.fmt.pix_mp.colorspace = vpe->src.colorspace;
 
    switch (vpe->deint) {
    case 1:
        fmt.fmt.pix_mp.field = V4L2_FIELD_ALTERNATE;
        break;
    case 2:
        fmt.fmt.pix_mp.field = V4L2_FIELD_SEQ_TB;
        break;
    case 0:
        fmt.fmt.pix_mp.field = V4L2_FIELD_TOP;
        break;
    default:
        fmt.fmt.pix_mp.field = V4L2_FIELD_ANY;
        break;
    }
 
    ret = ioctl(vpe->fd, VIDIOC_S_FMT, &fmt);
    if (ret < 0) {
        pexit( "vpe i/p: S_FMT failed: %s\n", strerror(errno));
    } else {
                vpe->src.size = fmt.fmt.pix_mp.plane_fmt[0].sizeimage;
                vpe->src.size_uv = fmt.fmt.pix_mp.plane_fmt[1].sizeimage;
        }
 
    ret = ioctl(vpe->fd, VIDIOC_G_FMT, &fmt);
    if (ret < 0)
        pexit( "vpe i/p: G_FMT_2 failed: %s\n", strerror(errno));
 
    MSG("vpe i/p: G_FMT: width = %u, height = %u, 4cc = %.4s",
            fmt.fmt.pix_mp.width, fmt.fmt.pix_mp.height,
            (char*)&fmt.fmt.pix_mp.pixelformat);
 
    set_crop(vpe);
 
    memset(&rqbufs, 0, sizeof(rqbufs));
    rqbufs.count = NUMBUF;
    rqbufs.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
    rqbufs.memory = V4L2_MEMORY_DMABUF;
 
    ret = ioctl(vpe->fd, VIDIOC_REQBUFS, &rqbufs);
    if (ret < 0)
        pexit( "vpe i/p: REQBUFS failed: %s\n", strerror(errno));
 
    vpe->src.numbuf = rqbufs.count;
    dprintf("vpe i/p: allocated buffers = %d\n", rqbufs.count);
    
    return 0;
 
}
 
/**
 *****************************************************************************
 * @brief:  Initialize vpe output by calling set_format, reqbuf ioctls.
 *      Also allocates buffer to display the vpe output. 
 *
 * @param:  vpe  struct vpe pointer
 *
 * @return: 0 on success 
 *****************************************************************************
*/
int vpe_output_init(struct vpe *vpe)
{
    int ret, i;
    struct v4l2_format fmt;
    struct v4l2_requestbuffers rqbufs;
 
    memset(&fmt, 0, sizeof fmt);
    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
 
    ret = ioctl(vpe->fd, VIDIOC_G_FMT, &fmt);
    if (ret < 0)
        pexit( "vpe o/p: G_FMT_1 failed: %s\n", strerror(errno));
 
    fmt.fmt.pix_mp.width = vpe->dst.width;
    fmt.fmt.pix_mp.height = vpe->dst.height;
    fmt.fmt.pix_mp.pixelformat = vpe->dst.fourcc;
    fmt.fmt.pix_mp.field = V4L2_FIELD_ANY;
    fmt.fmt.pix_mp.colorspace = vpe->dst.colorspace;
 
    ret = ioctl(vpe->fd, VIDIOC_S_FMT, &fmt);
    if (ret < 0)
        pexit( "vpe o/p: S_FMT failed: %s\n", strerror(errno));
 
    ret = ioctl(vpe->fd, VIDIOC_G_FMT, &fmt);
    if (ret < 0)
        pexit( "vpe o/p: G_FMT_2 failed: %s\n", strerror(errno));
 
    MSG("vpe o/p: G_FMT: width = %u, height = %u, 4cc = %.4s",
            fmt.fmt.pix_mp.width, fmt.fmt.pix_mp.height,
            (char*)&fmt.fmt.pix_mp.pixelformat);
 
    memset(&rqbufs, 0, sizeof(rqbufs));
    rqbufs.count = NUMBUF;
    rqbufs.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
    rqbufs.memory = V4L2_MEMORY_DMABUF;
 
    ret = ioctl(vpe->fd, VIDIOC_REQBUFS, &rqbufs);
    if (ret < 0)
        pexit( "vpe o/p: REQBUFS failed: %s\n", strerror(errno));
 
    vpe->dst.numbuf = rqbufs.count;
    dprintf("vpe o/p: allocated buffers = %d\n", rqbufs.count);
    
    vpe->disp_bufs = disp_get_vid_buffers(vpe->disp, NUMBUF, vpe->dst.fourcc, 
                          vpe->dst.width, vpe->dst.height);
    if (!vpe->disp_bufs)
        pexit("allocating display buffer failed\n");
 
    for (i = 0; i < NUMBUF; i++) {
        vpe->output_buf_dmafd[i] = omap_bo_dmabuf(vpe->disp_bufs[i]->bo[0]);
        vpe->disp_bufs[i]->fd[0] = vpe->output_buf_dmafd[i];
 
        if(vpe->dst.coplanar) {
            vpe->output_buf_dmafd_uv[i] = omap_bo_dmabuf(vpe->disp_bufs[i]->bo[1]);
            vpe->disp_bufs[i]->fd[1] = vpe->output_buf_dmafd_uv[i];
        }
        /* display only image widthxheight, no full screen */
//      vpe->disp_bufs[i]->noScale = true;
        dprintf("vpe->disp_bufs_fd[%d] = %d\n", i, vpe->output_buf_dmafd[i]);
    }
 
    dprintf("allocating display buffer success\n");
    return 0;
}
 
/**
 *****************************************************************************
 * @brief:  queue buffer to vpe input 
 *
 * @param:  vpe  struct vpe pointer
 * @param:  index  buffer index to queue
 *
 * @return: 0 on success 
 *****************************************************************************
*/
int vpe_input_qbuf(struct vpe *vpe, int index)
{
    int ret;
    struct v4l2_buffer buf;
    struct v4l2_plane planes[2];
 
    dprintf("vpe: src QBUF (%d):%s field", vpe->field,
        vpe->field==V4L2_FIELD_TOP?"top":"bottom");
 
    memset(&buf, 0, sizeof buf);
    memset(&planes, 0, sizeof planes);
 
    planes[0].length = planes[0].bytesused = vpe->src.size;
    if(vpe->src.coplanar)
        planes[1].length = planes[1].bytesused = vpe->src.size_uv;
 
    planes[0].data_offset = planes[1].data_offset = 0;
 
    buf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
    buf.memory = V4L2_MEMORY_DMABUF;
    buf.index = index;
    buf.m.planes = planes;
    buf.field = vpe->field;
    if(vpe->src.coplanar)
        buf.length = 2;
    else
        buf.length = 1;
 
    buf.m.planes[0].m.fd = vpe->input_buf_dmafd[index];
    if(vpe->src.coplanar)
        buf.m.planes[1].m.fd = vpe->input_buf_dmafd_uv[index];
 
    ret = ioctl(vpe->fd, VIDIOC_QBUF, &buf);
    if (ret < 0)
        pexit( "vpe i/p: QBUF failed: %s, index = %d\n",
            strerror(errno), index);
 
    return 0;
}
 
/**
 *****************************************************************************
 * @brief:  queue buffer to vpe output 
 *
 * @param:  vpe  struct vpe pointer
 * @param:  index  buffer index to queue
 *
 * @return: 0 on success 
 *****************************************************************************
*/
int vpe_output_qbuf(struct vpe *vpe, int index)
{
    int ret;
    struct v4l2_buffer buf;
    struct v4l2_plane planes[2];
 
    dprintf("vpe output buffer queue\n");
 
    memset(&buf, 0, sizeof buf);
    memset(&planes, 0, sizeof planes);
 
    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
    buf.memory = V4L2_MEMORY_DMABUF;
    buf.index = index;
    buf.m.planes = planes;
    if(vpe->dst.coplanar)
        buf.length = 2;
    else
        buf.length = 1;
 
    buf.m.planes[0].m.fd = vpe->output_buf_dmafd[index];
 
    if(vpe->dst.coplanar)
        buf.m.planes[1].m.fd = vpe->output_buf_dmafd_uv[index];
 
    ret = ioctl(vpe->fd, VIDIOC_QBUF, &buf);
    if (ret < 0)
        pexit( "vpe o/p: QBUF failed: %s, index = %d\n",
            strerror(errno), index);
 
    return 0;
}
 
/**
 *****************************************************************************
 * @brief:  start stream 
 *
 * @param:  fd  device fd
 * @param:  type  buffer type (CAPTURE or OUTPUT)
 *
 * @return: 0 on success 
 *****************************************************************************
*/
int vpe_stream_on(int fd, int type)
{
    int ret;
 
    ret = ioctl(fd, VIDIOC_STREAMON, &type);
    if (ret < 0)
        pexit("STREAMON failed,  %d: %s\n", type, strerror(errno));
 
    dprintf("stream ON: done! fd = %d,  type = %d\n", fd, type);
 
    return 0;
}
 
/**
 *****************************************************************************
 * @brief:  stop stream 
 *
 * @param:  fd  device fd
 * @param:  type  buffer type (CAPTURE or OUTPUT)
 *
 * @return: 0 on success 
 *****************************************************************************
*/
int vpe_stream_off(int fd, int type)
{
    int ret;
 
    ret = ioctl(fd, VIDIOC_STREAMOFF, &type);
    if (ret < 0)
        pexit("STREAMOFF failed, %d: %s\n", type, strerror(errno));
 
    dprintf("stream OFF: done! fd = %d,  type = %d\n", fd, type);
 
    return 0;
}
 
/**
 *****************************************************************************
 * @brief:  dequeue vpe input buffer  
 *
 * @param:  vpe  struct vpe pointer
 *
 * @return: buf.index index of dequeued buffer
 *****************************************************************************
*/
int vpe_input_dqbuf(struct vpe *vpe)
{
    int ret;
    struct v4l2_buffer buf;
    struct v4l2_plane planes[2];
    
    dprintf("vpe input dequeue buffer\n");
    
    memset(&buf, 0, sizeof buf);
    memset(&planes, 0, sizeof planes);
 
    buf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
    buf.memory = V4L2_MEMORY_DMABUF;
        buf.m.planes = planes;
    if(vpe->src.coplanar)
        buf.length = 2;
    else
        buf.length = 1;
    ret = ioctl(vpe->fd, VIDIOC_DQBUF, &buf);
    if (ret < 0)
        pexit("vpe i/p: DQBUF failed: %s\n", strerror(errno));
 
    dprintf("vpe i/p: DQBUF index = %d\n", buf.index);
 
    return buf.index;
}
 
/**
 *****************************************************************************
 * @brief:  dequeue vpe output buffer
 *
 * @param:  vpe  struct vpe pointer
 *
 * @return: buf.index index of dequeued buffer
 *****************************************************************************
*/
int vpe_output_dqbuf(struct vpe* vpe)
{
    int ret;
    struct v4l2_buffer buf;
    struct v4l2_plane planes[2];
 
    dprintf("vpe output dequeue buffer\n");
 
    memset(&buf, 0, sizeof buf);
    memset(&planes, 0, sizeof planes);
 
    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
    buf.memory = V4L2_MEMORY_DMABUF;
        buf.m.planes = planes;
    if(vpe->dst.coplanar)
        buf.length = 2;
    else
        buf.length = 1;
    ret = ioctl(vpe->fd, VIDIOC_DQBUF, &buf);
    if (ret < 0)
        pexit("vpe o/p: DQBUF failed: %s\n", strerror(errno));
 
    dprintf("vpe o/p: DQBUF index = %d\n", buf.index);
 
    return buf.index;
}
 
/**
  * @brief  Set vpe display buffer scale value. if noScale is false, it's full screen.
  * @param  vpe: pointer to parameter of struct vpe display
                 bfull: true/false about full screen 
  * @retval  none
  */
void vpe_output_fullscreen(struct vpe* vpe, bool bfull)
{
    int i;
    for(i=0; i<NUMBUF; i++)
        vpe->disp_bufs[i]->noScale = (bfull) ? false : true;
}
 
 
---------------------------v4l2.h-----------------------------------------

#ifndef V4L2_H_
#define V4L2_H_
 
#include "util.h"
#include <linux/videodev2.h>
 
struct v4l2 {
    int fd;
    int nbufs;
    struct v4l2_buffer *v4l2bufs;
    struct buffer **bufs;
};
 
/* Print v4l2 related help */
void v4l2_usage(void);
 
/* Open v4l2  */
struct v4l2 * v4l2_open(uint32_t fourcc, uint32_t width, uint32_t height);
void v4l2_close(struct v4l2 * v4l2);
 
/* Share the buffers w/ v4l2 via dmabuf */
int v4l2_reqbufs(struct v4l2 *v4l2, uint32_t n);
 
int v4l2_streamon(struct v4l2 *v4l2);
int v4l2_streamoff(struct v4l2 *v4l2);
 
/* Queue a buffer to the camera */
int v4l2_qbuf(struct v4l2 *v4l2, int dmafd, int index);
 
/* Dequeue buffer from camera */
int v4l2_dqbuf(struct v4l2 *v4l2, int* field);
 
#endif
---------------------------v4l2.c---------------------------------------

/*
 * Copyright (C) 2011 Texas Instruments
 * Author: Rob Clark <rob.clark@linaro.org>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published by
 * the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 */

//#ifdef HAVE_CONFIG_H
#include "config.h"
//#endif

#include <linux/videodev2.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <pthread.h>

#include <omap_drmif.h>

#include "util.h"
#include "v4l2.h"

void
v4l2_usage(void)
{
    MSG("V4L2 Capture Options:");
    MSG("\t-c WxH@fourcc\tset capture dimensions/format");
    MSG("\t-m\t\tdo MCF setup");
}

struct v4l2* v4l2_open(uint32_t fourcc, uint32_t width, uint32_t height)
{
    struct v4l2_format format = {
            .type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
    };
    struct v4l2 *v4l2;
    int ret;
   
    char devname[20] = "/dev/video1";

    v4l2 = calloc(1, sizeof(*v4l2));

    v4l2->fd = open(devname, O_RDWR);

    ret = ioctl(v4l2->fd, VIDIOC_G_FMT, &format);
    if (ret < 0) {
        ERROR("VIDIOC_G_FMT failed: %s (%d)", strerror(errno), ret);
        goto fail;
    }

    format.fmt.pix.pixelformat = fourcc;
    format.fmt.pix.width = width;
    format.fmt.pix.height = height;

    if ((format.fmt.pix.width == 0) || (format.fmt.pix.height == 0) ||
            (format.fmt.pix.pixelformat == 0)) {

        ERROR("invalid capture settings '%dx%d@%4s'",
            format.fmt.pix.width, format.fmt.pix.height,
            (char *)&format.fmt.pix.pixelformat);
        goto fail;
    }

    ret = ioctl(v4l2->fd, VIDIOC_S_FMT, &format);
    if (ret < 0) {
        ERROR("VIDIOC_S_FMT failed: %s (%d)", strerror(errno), ret);
        goto fail;
    }

    return v4l2;

fail:
    // XXX cleanup
    free(v4l2);
    return NULL;
}

void v4l2_close(struct v4l2 * v4l2)
{
    close(v4l2->fd);
    free(v4l2);
}

int
v4l2_reqbufs(struct v4l2 *v4l2, uint32_t n)
{
#if 1
    int ret;
    struct v4l2_requestbuffers rqbufs;

    memset(&rqbufs, 0, sizeof(rqbufs));
    rqbufs.count = n;
    rqbufs.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    rqbufs.memory = V4L2_MEMORY_DMABUF;

    ret = ioctl(v4l2->fd, VIDIOC_REQBUFS, &rqbufs);
    if (ret < 0)
        ERROR("REQBUFS failed: %s\n", strerror(errno));

    DBG("allocated buffers = %d\n", rqbufs.count);

    return 0;

#else
    struct v4l2_requestbuffers reqbuf = {
            .type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
            .memory = V4L2_MEMORY_DMABUF,
            .count = n,
    };
    uint32_t i;
    int ret,dmafd;

    if (v4l2->v4l2bufs) {
        // maybe eventually need to support this?
        ERROR("already reqbuf'd");
        return -1;
    }

    ret = ioctl(v4l2->fd, VIDIOC_REQBUFS, &reqbuf);
    if (ret < 0) {
        ERROR("VIDIOC_REQBUFS failed: %s (%d)", strerror(errno), ret);
        return ret;
    }

    if ((reqbuf.count != n) ||
            (reqbuf.type != V4L2_BUF_TYPE_VIDEO_CAPTURE) ||
            (reqbuf.memory != V4L2_MEMORY_DMABUF)) {
        ERROR("unsupported..");
        return -1;
    }

#if 0
    v4l2->nbufs = reqbuf.count;
    v4l2->bufs = bufs;
    v4l2->v4l2bufs = calloc(v4l2->nbufs, sizeof(*v4l2->v4l2bufs));
    if (!v4l2->v4l2bufs) {
        ERROR("allocation failed");
        return -1;
    }

    for (i = 0; i < reqbuf.count; i++) {
        assert(bufs[i]->nbo == 1); /* TODO add multi-planar support */
        /* Call omap_bo_dmabuf only once, to export only once
         * Otherwise, each call will return duplicated fds
         * This way, every call to omap_bo_dmabuf will return a new fd
         * Which won't match with any previously exported fds
         * Instead, store dma fd in buf->fd[] */
        dmafd = omap_bo_dmabuf(bufs[i]->bo[0]);
        bufs[i]->fd[0] = dmafd;
        v4l2->v4l2bufs[i] = (struct v4l2_buffer){
            .type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
                    .memory = V4L2_MEMORY_DMABUF,
                    .index = i,
                    .m.fd = dmafd,
        };
        MSG("Exported buffer fd = %d\n", dmafd);
        ret = ioctl(v4l2->fd, VIDIOC_QUERYBUF, &v4l2->v4l2bufs[i]);
        v4l2->v4l2bufs[i].m.fd = dmafd;
        if (ret) {
            ERROR("VIDIOC_QUERYBUF failed: %s (%d)", strerror(errno), ret);
            return ret;
        }
    }
#endif
#endif
    return 0;
}

int
v4l2_streamon(struct v4l2 *v4l2)
{
    enum v4l2_buf_type type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    int ret;

    ret = ioctl(v4l2->fd, VIDIOC_STREAMON, &type);

    if (ret) {
        ERROR("VIDIOC_STREAMON failed: %s (%d)", strerror(errno), ret);
    }

    return ret;
}

int
v4l2_streamoff(struct v4l2 *v4l2)
{
    enum v4l2_buf_type type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    int ret;

    ret = ioctl(v4l2->fd, VIDIOC_STREAMOFF, &type);

    if (ret) {
        ERROR("VIDIOC_STREAMOFF failed: %s (%d)", strerror(errno), ret);
    }

    return ret;
}

int
v4l2_qbuf(struct v4l2 *v4l2, int dmafd, int index)
{
#if 1
    int ret;
    struct v4l2_buffer buf;

    DBG("v4l2 buffer queue\n");

    memset(&buf, 0, sizeof buf);
    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    buf.memory = V4L2_MEMORY_DMABUF;
    buf.index = index;
    buf.m.fd = dmafd; //vpe->input_buf_dmafd[index];
    //printf("%d, %d(%d), %d(%d), %d, %d\n",
    //  vipfd, buf.type, V4L2_BUF_TYPE_VIDEO_CAPTURE, buf.memory, V4L2_MEMORY_DMABUF, buf.index, buf.m.fd);

    ret = ioctl(v4l2->fd, VIDIOC_QBUF, &buf);
    if (ret < 0)
        ERROR("QBUF failed: %s, index = %d\n", strerror(errno), index);

    return 0;
#else
    struct v4l2_buffer *v4l2buf = NULL;
    int i, ret, fd;

    struct timeval disp_time;
    struct timeval disp_lat;
    pthread_t tid;

    assert(buf->nbo == 1); /* TODO add multi-planar support */

    fd = buf->fd[0];

    for (i = 0; i < v4l2->nbufs; i++) {
        if (v4l2->v4l2bufs[i].m.fd == fd) {
            v4l2buf = &v4l2->v4l2bufs[i];
        }
    }

    tid = pthread_self();
    gettimeofday(&disp_time, NULL);
    timersub(&disp_time, &v4l2buf->timestamp, &disp_lat);
    if(v4l2buf->timestamp.tv_sec)
        DBG("%x: DISP latency = %d.%6d", (unsigned int)tid, (int)disp_lat.tv_sec, (int)disp_lat.tv_usec);

    if (!v4l2buf) {
        ERROR("invalid buffer");
        return -1;
    }

    ret = ioctl(v4l2->fd, VIDIOC_QBUF, v4l2buf);
    v4l2buf->m.fd = buf->fd[0];
    if (ret) {
        ERROR("VIDIOC_QBUF failed: %s (%d)", strerror(errno), ret);
    }
    return ret;
#endif

}

int
v4l2_dqbuf(struct v4l2 *v4l2, int* field)
{
    struct v4l2_buffer v4l2buf = {
            .type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
            .memory = V4L2_MEMORY_DMABUF,
    };
    int ret;

    ret = ioctl(v4l2->fd, VIDIOC_DQBUF, &v4l2buf);
    if (ret) {
        ERROR("VIDIOC_DQBUF failed: %s (%d)", strerror(errno), ret);
    }

#if 1
    DBG("vip: DQBUF idx = %d, field = %s\n", v4l2buf.index,
        v4l2buf.field == V4L2_FIELD_TOP? "Top" : "Bottom");
    *field = v4l2buf.field;

    return v4l2buf.index;
#else
    buf = v4l2->bufs[v4l2buf.index];
    v4l2->v4l2bufs[v4l2buf.index].timestamp = v4l2buf.timestamp;

    assert(buf->nbo == 1); /* TODO add multi-planar support */

    tid = pthread_self();
    gettimeofday(&dq_time, NULL);
    timersub(&dq_time, &v4l2buf.timestamp, &dq_lat);
    DBG("%x: DQ latency = %d.%6d", (unsigned int)tid, (int)dq_lat.tv_sec, (int)dq_lat.tv_usec);

    return buf;
#endif
}
---------------------------------------util.c-------------------------------------------------

/*
 * Copyright (C) 2011 Texas Instruments
 * Author: Rob Clark <rob.clark@linaro.org>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published by
 * the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "util.h"

/* Dynamic debug. */
int debug = 0;

/* Maintain playback rate if fps > 0. */
void maintain_playback_rate(struct rate_control *p)
{
    long usecs_since_last_frame;
    int usecs_between_frames, usecs_to_sleep;

    if (p->fps <= 0)
        return;

    usecs_between_frames = 1000000 / p->fps;
    usecs_since_last_frame = mark(&p->last_frame_mark);
    DBG("fps: %.02f", 1000000.0 / usecs_since_last_frame);
    usecs_to_sleep = usecs_between_frames - usecs_since_last_frame + p->usecs_to_sleep;

    if (usecs_to_sleep < 0)
        usecs_to_sleep = 0;

    /* mark() has a limitation that >1s time deltas will make the whole
     * loop diverge. Workaround that limitation by clamping our desired sleep time
     * to a maximum. TODO: Remove when mark() is in better shape. */
    if (usecs_to_sleep >= 1000000)
        usecs_to_sleep = 999999;

    /* We filter a bit our rate adaptation, to avoid being too "choppy".
     * Adjust the "alpha" value as needed. */
    p->usecs_to_sleep = ((67 * p->usecs_to_sleep) + (33 * usecs_to_sleep)) / 100;

    if (p->usecs_to_sleep >= 1) {
        DBG("sleeping %dus", p->usecs_to_sleep);
        usleep(p->usecs_to_sleep);
    }
}

int
check_args(int argc, char **argv)
{
    int i;
    for (i = 1; i < argc; i++) {
        if (argv[i]) {
            ERROR("invalid arg: %s", argv[i]);
            return -1;
        }
    }
    return 0;
}

---------------------------------list.h---------------------------------------------

/*
 * Copyright ⓒ 2010 Intel Corporation
 * Copyright ⓒ 2010 Francisco Jerez <currojerez@riseup.net>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 */

#ifndef _LIST_H_
#define _LIST_H_

/**
 * @file Classic doubly-link circular list implementation.
 * For real usage examples of the linked list, see the file test/list.c
 *
 * Example:
 * We need to keep a list of struct foo in the parent struct bar, i.e. what
 * we want is something like this.
 *
 *     struct bar {
 *          ...
 *          struct foo *list_of_foos; -----> struct foo {}, struct foo {}, struct foo{}
 *          ...
 *     }
 *
 * We need one list head in bar and a list element in all list_of_foos (both are of
 * data type 'struct list').
 *
 *     struct bar {
 *          ...
 *          struct list list_of_foos;
 *          ...
 *     }
 *
 *     struct foo {
 *          ...
 *          struct list entry;
 *          ...
 *     }
 *
 * Now we initialize the list head:
 *
 *     struct bar bar;
 *     ...
 *     list_init(&bar.list_of_foos);
 *
 * Then we create the first element and add it to this list:
 *
 *     struct foo *foo = malloc(...);
 *     ....
 *     list_add(&foo->entry, &bar.list_of_foos);
 *
 * Repeat the above for each element you want to add to the list. Deleting
 * works with the element itself.
 *      list_del(&foo->entry);
 *      free(foo);
 *
 * Note: calling list_del(&bar.list_of_foos) will set bar.list_of_foos to an empty
 * list again.
 *
 * Looping through the list requires a 'struct foo' as iterator and the
 * name of the field the subnodes use.
 *
 * struct foo *iterator;
 * list_for_each_entry(iterator, &bar.list_of_foos, entry) {
 *      if (iterator->something == ...)
 *             ...
 * }
 *
 * Note: You must not call list_del() on the iterator if you continue the
 * loop. You need to run the safe for-each loop instead:
 *
 * struct foo *iterator, *next;
 * list_for_each_entry_safe(iterator, next, &bar.list_of_foos, entry) {
 *      if (...)
 *              list_del(&iterator->entry);
 * }
 *
 */

/**
 * The linkage struct for list nodes. This struct must be part of your
 * to-be-linked struct. struct list is required for both the head of the
 * list and for each list node.
 *
 * Position and name of the struct list field is irrelevant.
 * There are no requirements that elements of a list are of the same type.
 * There are no requirements for a list head, any struct list can be a list
 * head.
 */
struct list {
    struct list *next, *prev;
};

/**
 * Initialize the list as an empty list.
 *
 * Example:
 * list_init(&bar->list_of_foos);
 *
 * @param The list to initialized.
 */
static void
list_init(struct list *list)
{
    list->next = list->prev = list;
}

static inline void
__list_add(struct list *entry,
        struct list *prev,
        struct list *next)
{
    next->prev = entry;
    entry->next = next;
    entry->prev = prev;
    prev->next = entry;
}

/**
 * Insert a new element after the given list head. The new element does not
 * need to be initialised as empty list.
 * The list changes from:
 *      head → some element → ...
 * to
 *      head → new element → older element → ...
 *
 * Example:
 * struct foo *newfoo = malloc(...);
 * list_add(&newfoo->entry, &bar->list_of_foos);
 *
 * @param entry The new element to prepend to the list.
 * @param head The existing list.
 */
static inline void
list_add(struct list *entry, struct list *head)
{
    __list_add(entry, head, head->next);
}

/**
 * Append a new element to the end of the list given with this list head.
 *
 * The list changes from:
 *      head → some element → ... → lastelement
 * to
 *      head → some element → ... → lastelement → new element
 *
 * Example:
 * struct foo *newfoo = malloc(...);
 * list_append(&newfoo->entry, &bar->list_of_foos);
 *
 * @param entry The new element to prepend to the list.
 * @param head The existing list.
 */
static inline void
list_append(struct list *entry, struct list *head)
{
    __list_add(entry, head->prev, head);
}


static inline void
__list_del(struct list *prev, struct list *next)
{
    next->prev = prev;
    prev->next = next;
}

/**
 * Remove the element from the list it is in. Using this function will reset
 * the pointers to/from this element so it is removed from the list. It does
 * NOT free the element itself or manipulate it otherwise.
 *
 * Using list_del on a pure list head (like in the example at the top of
 * this file) will NOT remove the first element from
 * the list but rather reset the list as empty list.
 *
 * Example:
 * list_del(&foo->entry);
 *
 * @param entry The element to remove.
 */
static inline void
list_del(struct list *entry)
{
    __list_del(entry->prev, entry->next);
    list_init(entry);
}

/**
 * Check if the list is empty.
 *
 * Example:
 * list_is_empty(&bar->list_of_foos);
 *
 * @return True if the list contains one or more elements or False otherwise.
 */
static inline bool
list_is_empty(struct list *head)
{
    return head->next == head;
}

/**
 * Returns a pointer to the container of this list element.
 *
 * Example:
 * struct foo* f;
 * f = container_of(&foo->entry, struct foo, entry);
 * assert(f == foo);
 *
 * @param ptr Pointer to the struct list.
 * @param type Data type of the list element.
 * @param member Member name of the struct list field in the list element.
 * @return A pointer to the data struct containing the list head.
 */
#ifndef container_of
#define container_of(ptr, type, member) \
    (type *)((char *)(ptr) - (char *) &((type *)0)->member)
#endif

/**
 * Alias of container_of
 */
#define list_entry(ptr, type, member) \
    container_of(ptr, type, member)

/**
 * Retrieve the first list entry for the given list pointer.
 *
 * Example:
 * struct foo *first;
 * first = list_first_entry(&bar->list_of_foos, struct foo, list_of_foos);
 *
 * @param ptr The list head
 * @param type Data type of the list element to retrieve
 * @param member Member name of the struct list field in the list element.
 * @return A pointer to the first list element.
 */
#define list_first_entry(ptr, type, member) \
    list_entry((ptr)->next, type, member)

/**
 * Retrieve the last list entry for the given listpointer.
 *
 * Example:
 * struct foo *first;
 * first = list_last_entry(&bar->list_of_foos, struct foo, list_of_foos);
 *
 * @param ptr The list head
 * @param type Data type of the list element to retrieve
 * @param member Member name of the struct list field in the list element.
 * @return A pointer to the last list element.
 */
#define list_last_entry(ptr, type, member) \
    list_entry((ptr)->prev, type, member)

#define __container_of(ptr, sample, member)             \
    (void *)((char *)(ptr)                      \
         - ((char *)&(sample)->member - (char *)(sample)))
/**
 * Loop through the list given by head and set pos to struct in the list.
 *
 * Example:
 * struct foo *iterator;
 * list_for_each_entry(iterator, &bar->list_of_foos, entry) {
 *      [modify iterator]
 * }
 *
 * This macro is not safe for node deletion. Use list_for_each_entry_safe
 * instead.
 *
 * @param pos Iterator variable of the type of the list elements.
 * @param head List head
 * @param member Member name of the struct list in the list elements.
 *
 */
#define list_for_each_entry(pos, head, member)              \
    for (pos = __container_of((head)->next, pos, member);       \
     &pos->member != (head);                    \
     pos = __container_of(pos->member.next, pos, member))

/**
 * Loop through the list, keeping a backup pointer to the element. This
 * macro allows for the deletion of a list element while looping through the
 * list.
 *
 * See list_for_each_entry for more details.
 */
#define list_for_each_entry_safe(pos, tmp, head, member)        \
    for (pos = __container_of((head)->next, pos, member),       \
     tmp = __container_of(pos->member.next, pos, member);       \
     &pos->member != (head);                    \
     pos = tmp, tmp = __container_of(pos->member.next, tmp, member))

#endif
---------------------------------------input_cmd.cpp------------------------------------

 
#include <iostream>
#include <stdio.h>
#include <string.h>
 
using namespace std;
 
extern "C" {
 
char StandbyInput(char *inputbuf)
{
    string sInput;
 
    getline(cin,sInput,'\n');
    strcpy(inputbuf, sInput.c_str());
    return false;
}
 
}
 
------------------------------font_8x8.h------------------------

/**********************************************/
/*                                            */
/*       Font file generated by cpi2fnt       */
/*                                            */
/**********************************************/
 
const uint8_t fontdata_8x8[] = {
 
    /* 0 0x00 '^@' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 1 0x01 '^A' */
    0x7e, /* 01111110 */
    0x81, /* 10000001 */
    0xa5, /* 10100101 */
    0x81, /* 10000001 */
    0xbd, /* 10111101 */
    0x99, /* 10011001 */
    0x81, /* 10000001 */
    0x7e, /* 01111110 */
 
    /* 2 0x02 '^B' */
    0x7e, /* 01111110 */
    0xff, /* 11111111 */
    0xdb, /* 11011011 */
    0xff, /* 11111111 */
    0xc3, /* 11000011 */
    0xe7, /* 11100111 */
    0xff, /* 11111111 */
    0x7e, /* 01111110 */
 
    /* 3 0x03 '^C' */
    0x6c, /* 01101100 */
    0xfe, /* 11111110 */
    0xfe, /* 11111110 */
    0xfe, /* 11111110 */
    0x7c, /* 01111100 */
    0x38, /* 00111000 */
    0x10, /* 00010000 */
    0x00, /* 00000000 */
 
    /* 4 0x04 '^D' */
    0x10, /* 00010000 */
    0x38, /* 00111000 */
    0x7c, /* 01111100 */
    0xfe, /* 11111110 */
    0x7c, /* 01111100 */
    0x38, /* 00111000 */
    0x10, /* 00010000 */
    0x00, /* 00000000 */
 
    /* 5 0x05 '^E' */
    0x38, /* 00111000 */
    0x7c, /* 01111100 */
    0x38, /* 00111000 */
    0xfe, /* 11111110 */
    0xfe, /* 11111110 */
    0xd6, /* 11010110 */
    0x10, /* 00010000 */
    0x38, /* 00111000 */
 
    /* 6 0x06 '^F' */
    0x10, /* 00010000 */
    0x38, /* 00111000 */
    0x7c, /* 01111100 */
    0xfe, /* 11111110 */
    0xfe, /* 11111110 */
    0x7c, /* 01111100 */
    0x10, /* 00010000 */
    0x38, /* 00111000 */
 
    /* 7 0x07 '^G' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x18, /* 00011000 */
    0x3c, /* 00111100 */
    0x3c, /* 00111100 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 8 0x08 '^H' */
    0xff, /* 11111111 */
    0xff, /* 11111111 */
    0xe7, /* 11100111 */
    0xc3, /* 11000011 */
    0xc3, /* 11000011 */
    0xe7, /* 11100111 */
    0xff, /* 11111111 */
    0xff, /* 11111111 */
 
    /* 9 0x09 '^I' */
    0x00, /* 00000000 */
    0x3c, /* 00111100 */
    0x66, /* 01100110 */
    0x42, /* 01000010 */
    0x42, /* 01000010 */
    0x66, /* 01100110 */
    0x3c, /* 00111100 */
    0x00, /* 00000000 */
 
    /* 10 0x0a '^J' */
    0xff, /* 11111111 */
    0xc3, /* 11000011 */
    0x99, /* 10011001 */
    0xbd, /* 10111101 */
    0xbd, /* 10111101 */
    0x99, /* 10011001 */
    0xc3, /* 11000011 */
    0xff, /* 11111111 */
 
    /* 11 0x0b '^K' */
    0x0f, /* 00001111 */
    0x07, /* 00000111 */
    0x0f, /* 00001111 */
    0x7d, /* 01111101 */
    0xcc, /* 11001100 */
    0xcc, /* 11001100 */
    0xcc, /* 11001100 */
    0x78, /* 01111000 */
 
    /* 12 0x0c '^L' */
    0x3c, /* 00111100 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x3c, /* 00111100 */
    0x18, /* 00011000 */
    0x7e, /* 01111110 */
    0x18, /* 00011000 */
 
    /* 13 0x0d '^M' */
    0x3f, /* 00111111 */
    0x33, /* 00110011 */
    0x3f, /* 00111111 */
    0x30, /* 00110000 */
    0x30, /* 00110000 */
    0x70, /* 01110000 */
    0xf0, /* 11110000 */
    0xe0, /* 11100000 */
 
    /* 14 0x0e '^N' */
    0x7f, /* 01111111 */
    0x63, /* 01100011 */
    0x7f, /* 01111111 */
    0x63, /* 01100011 */
    0x63, /* 01100011 */
    0x67, /* 01100111 */
    0xe6, /* 11100110 */
    0xc0, /* 11000000 */
 
    /* 15 0x0f '^O' */
    0x18, /* 00011000 */
    0xdb, /* 11011011 */
    0x3c, /* 00111100 */
    0xe7, /* 11100111 */
    0xe7, /* 11100111 */
    0x3c, /* 00111100 */
    0xdb, /* 11011011 */
    0x18, /* 00011000 */
 
    /* 16 0x10 '^P' */
    0x80, /* 10000000 */
    0xe0, /* 11100000 */
    0xf8, /* 11111000 */
    0xfe, /* 11111110 */
    0xf8, /* 11111000 */
    0xe0, /* 11100000 */
    0x80, /* 10000000 */
    0x00, /* 00000000 */
 
    /* 17 0x11 '^Q' */
    0x02, /* 00000010 */
    0x0e, /* 00001110 */
    0x3e, /* 00111110 */
    0xfe, /* 11111110 */
    0x3e, /* 00111110 */
    0x0e, /* 00001110 */
    0x02, /* 00000010 */
    0x00, /* 00000000 */
 
    /* 18 0x12 '^R' */
    0x18, /* 00011000 */
    0x3c, /* 00111100 */
    0x7e, /* 01111110 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x7e, /* 01111110 */
    0x3c, /* 00111100 */
    0x18, /* 00011000 */
 
    /* 19 0x13 '^S' */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x00, /* 00000000 */
    0x66, /* 01100110 */
    0x00, /* 00000000 */
 
    /* 20 0x14 '^T' */
    0x7f, /* 01111111 */
    0xdb, /* 11011011 */
    0xdb, /* 11011011 */
    0x7b, /* 01111011 */
    0x1b, /* 00011011 */
    0x1b, /* 00011011 */
    0x1b, /* 00011011 */
    0x00, /* 00000000 */
 
    /* 21 0x15 '^U' */
    0x3e, /* 00111110 */
    0x61, /* 01100001 */
    0x3c, /* 00111100 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x3c, /* 00111100 */
    0x86, /* 10000110 */
    0x7c, /* 01111100 */
 
    /* 22 0x16 '^V' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x7e, /* 01111110 */
    0x7e, /* 01111110 */
    0x7e, /* 01111110 */
    0x00, /* 00000000 */
 
    /* 23 0x17 '^W' */
    0x18, /* 00011000 */
    0x3c, /* 00111100 */
    0x7e, /* 01111110 */
    0x18, /* 00011000 */
    0x7e, /* 01111110 */
    0x3c, /* 00111100 */
    0x18, /* 00011000 */
    0xff, /* 11111111 */
 
    /* 24 0x18 '^X' */
    0x18, /* 00011000 */
    0x3c, /* 00111100 */
    0x7e, /* 01111110 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
 
    /* 25 0x19 '^Y' */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x7e, /* 01111110 */
    0x3c, /* 00111100 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
 
    /* 26 0x1a '^Z' */
    0x00, /* 00000000 */
    0x18, /* 00011000 */
    0x0c, /* 00001100 */
    0xfe, /* 11111110 */
    0x0c, /* 00001100 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 27 0x1b '^[' */
    0x00, /* 00000000 */
    0x30, /* 00110000 */
    0x60, /* 01100000 */
    0xfe, /* 11111110 */
    0x60, /* 01100000 */
    0x30, /* 00110000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 28 0x1c '^\' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xc0, /* 11000000 */
    0xc0, /* 11000000 */
    0xc0, /* 11000000 */
    0xfe, /* 11111110 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 29 0x1d '^]' */
    0x00, /* 00000000 */
    0x24, /* 00100100 */
    0x66, /* 01100110 */
    0xff, /* 11111111 */
    0x66, /* 01100110 */
    0x24, /* 00100100 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 30 0x1e '^^' */
    0x00, /* 00000000 */
    0x18, /* 00011000 */
    0x3c, /* 00111100 */
    0x7e, /* 01111110 */
    0xff, /* 11111111 */
    0xff, /* 11111111 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 31 0x1f '^_' */
    0x00, /* 00000000 */
    0xff, /* 11111111 */
    0xff, /* 11111111 */
    0x7e, /* 01111110 */
    0x3c, /* 00111100 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 32 0x20 ' ' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 33 0x21 '!' */
    0x18, /* 00011000 */
    0x3c, /* 00111100 */
    0x3c, /* 00111100 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
 
    /* 34 0x22 '"' */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x24, /* 00100100 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 35 0x23 '#' */
    0x6c, /* 01101100 */
    0x6c, /* 01101100 */
    0xfe, /* 11111110 */
    0x6c, /* 01101100 */
    0xfe, /* 11111110 */
    0x6c, /* 01101100 */
    0x6c, /* 01101100 */
    0x00, /* 00000000 */
 
    /* 36 0x24 '$' */
    0x18, /* 00011000 */
    0x3e, /* 00111110 */
    0x60, /* 01100000 */
    0x3c, /* 00111100 */
    0x06, /* 00000110 */
    0x7c, /* 01111100 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
 
    /* 37 0x25 '%' */
    0x00, /* 00000000 */
    0xc6, /* 11000110 */
    0xcc, /* 11001100 */
    0x18, /* 00011000 */
    0x30, /* 00110000 */
    0x66, /* 01100110 */
    0xc6, /* 11000110 */
    0x00, /* 00000000 */
 
    /* 38 0x26 '&' */
    0x38, /* 00111000 */
    0x6c, /* 01101100 */
    0x38, /* 00111000 */
    0x76, /* 01110110 */
    0xdc, /* 11011100 */
    0xcc, /* 11001100 */
    0x76, /* 01110110 */
    0x00, /* 00000000 */
 
    /* 39 0x27 ''' */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x30, /* 00110000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 40 0x28 '(' */
    0x0c, /* 00001100 */
    0x18, /* 00011000 */
    0x30, /* 00110000 */
    0x30, /* 00110000 */
    0x30, /* 00110000 */
    0x18, /* 00011000 */
    0x0c, /* 00001100 */
    0x00, /* 00000000 */
 
    /* 41 0x29 ')' */
    0x30, /* 00110000 */
    0x18, /* 00011000 */
    0x0c, /* 00001100 */
    0x0c, /* 00001100 */
    0x0c, /* 00001100 */
    0x18, /* 00011000 */
    0x30, /* 00110000 */
    0x00, /* 00000000 */
 
    /* 42 0x2a '*' */
    0x00, /* 00000000 */
    0x66, /* 01100110 */
    0x3c, /* 00111100 */
    0xff, /* 11111111 */
    0x3c, /* 00111100 */
    0x66, /* 01100110 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 43 0x2b '+' */
    0x00, /* 00000000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x7e, /* 01111110 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 44 0x2c ',' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x30, /* 00110000 */
 
    /* 45 0x2d '-' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x7e, /* 01111110 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 46 0x2e '.' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
 
    /* 47 0x2f '/' */
    0x06, /* 00000110 */
    0x0c, /* 00001100 */
    0x18, /* 00011000 */
    0x30, /* 00110000 */
    0x60, /* 01100000 */
    0xc0, /* 11000000 */
    0x80, /* 10000000 */
    0x00, /* 00000000 */
 
    /* 48 0x30 '0' */
    0x38, /* 00111000 */
    0x6c, /* 01101100 */
    0xc6, /* 11000110 */
    0xd6, /* 11010110 */
    0xc6, /* 11000110 */
    0x6c, /* 01101100 */
    0x38, /* 00111000 */
    0x00, /* 00000000 */
 
    /* 49 0x31 '1' */
    0x18, /* 00011000 */
    0x38, /* 00111000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x7e, /* 01111110 */
    0x00, /* 00000000 */
 
    /* 50 0x32 '2' */
    0x7c, /* 01111100 */
    0xc6, /* 11000110 */
    0x06, /* 00000110 */
    0x1c, /* 00011100 */
    0x30, /* 00110000 */
    0x66, /* 01100110 */
    0xfe, /* 11111110 */
    0x00, /* 00000000 */
 
    /* 51 0x33 '3' */
    0x7c, /* 01111100 */
    0xc6, /* 11000110 */
    0x06, /* 00000110 */
    0x3c, /* 00111100 */
    0x06, /* 00000110 */
    0xc6, /* 11000110 */
    0x7c, /* 01111100 */
    0x00, /* 00000000 */
 
    /* 52 0x34 '4' */
    0x1c, /* 00011100 */
    0x3c, /* 00111100 */
    0x6c, /* 01101100 */
    0xcc, /* 11001100 */
    0xfe, /* 11111110 */
    0x0c, /* 00001100 */
    0x1e, /* 00011110 */
    0x00, /* 00000000 */
 
    /* 53 0x35 '5' */
    0xfe, /* 11111110 */
    0xc0, /* 11000000 */
    0xc0, /* 11000000 */
    0xfc, /* 11111100 */
    0x06, /* 00000110 */
    0xc6, /* 11000110 */
    0x7c, /* 01111100 */
    0x00, /* 00000000 */
 
    /* 54 0x36 '6' */
    0x38, /* 00111000 */
    0x60, /* 01100000 */
    0xc0, /* 11000000 */
    0xfc, /* 11111100 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x7c, /* 01111100 */
    0x00, /* 00000000 */
 
    /* 55 0x37 '7' */
    0xfe, /* 11111110 */
    0xc6, /* 11000110 */
    0x0c, /* 00001100 */
    0x18, /* 00011000 */
    0x30, /* 00110000 */
    0x30, /* 00110000 */
    0x30, /* 00110000 */
    0x00, /* 00000000 */
 
    /* 56 0x38 '8' */
    0x7c, /* 01111100 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x7c, /* 01111100 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x7c, /* 01111100 */
    0x00, /* 00000000 */
 
    /* 57 0x39 '9' */
    0x7c, /* 01111100 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x7e, /* 01111110 */
    0x06, /* 00000110 */
    0x0c, /* 00001100 */
    0x78, /* 01111000 */
    0x00, /* 00000000 */
 
    /* 58 0x3a ':' */
    0x00, /* 00000000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
 
    /* 59 0x3b ';' */
    0x00, /* 00000000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x30, /* 00110000 */
 
    /* 60 0x3c '<' */
    0x06, /* 00000110 */
    0x0c, /* 00001100 */
    0x18, /* 00011000 */
    0x30, /* 00110000 */
    0x18, /* 00011000 */
    0x0c, /* 00001100 */
    0x06, /* 00000110 */
    0x00, /* 00000000 */
 
    /* 61 0x3d '=' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x7e, /* 01111110 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x7e, /* 01111110 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 62 0x3e '>' */
    0x60, /* 01100000 */
    0x30, /* 00110000 */
    0x18, /* 00011000 */
    0x0c, /* 00001100 */
    0x18, /* 00011000 */
    0x30, /* 00110000 */
    0x60, /* 01100000 */
    0x00, /* 00000000 */
 
    /* 63 0x3f '?' */
    0x7c, /* 01111100 */
    0xc6, /* 11000110 */
    0x0c, /* 00001100 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
 
    /* 64 0x40 '@' */
    0x7c, /* 01111100 */
    0xc6, /* 11000110 */
    0xde, /* 11011110 */
    0xde, /* 11011110 */
    0xde, /* 11011110 */
    0xc0, /* 11000000 */
    0x78, /* 01111000 */
    0x00, /* 00000000 */
 
    /* 65 0x41 'A' */
    0x38, /* 00111000 */
    0x6c, /* 01101100 */
    0xc6, /* 11000110 */
    0xfe, /* 11111110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x00, /* 00000000 */
 
    /* 66 0x42 'B' */
    0xfc, /* 11111100 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x7c, /* 01111100 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0xfc, /* 11111100 */
    0x00, /* 00000000 */
 
    /* 67 0x43 'C' */
    0x3c, /* 00111100 */
    0x66, /* 01100110 */
    0xc0, /* 11000000 */
    0xc0, /* 11000000 */
    0xc0, /* 11000000 */
    0x66, /* 01100110 */
    0x3c, /* 00111100 */
    0x00, /* 00000000 */
 
    /* 68 0x44 'D' */
    0xf8, /* 11111000 */
    0x6c, /* 01101100 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x6c, /* 01101100 */
    0xf8, /* 11111000 */
    0x00, /* 00000000 */
 
    /* 69 0x45 'E' */
    0xfe, /* 11111110 */
    0x62, /* 01100010 */
    0x68, /* 01101000 */
    0x78, /* 01111000 */
    0x68, /* 01101000 */
    0x62, /* 01100010 */
    0xfe, /* 11111110 */
    0x00, /* 00000000 */
 
    /* 70 0x46 'F' */
    0xfe, /* 11111110 */
    0x62, /* 01100010 */
    0x68, /* 01101000 */
    0x78, /* 01111000 */
    0x68, /* 01101000 */
    0x60, /* 01100000 */
    0xf0, /* 11110000 */
    0x00, /* 00000000 */
 
    /* 71 0x47 'G' */
    0x3c, /* 00111100 */
    0x66, /* 01100110 */
    0xc0, /* 11000000 */
    0xc0, /* 11000000 */
    0xce, /* 11001110 */
    0x66, /* 01100110 */
    0x3a, /* 00111010 */
    0x00, /* 00000000 */
 
    /* 72 0x48 'H' */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xfe, /* 11111110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x00, /* 00000000 */
 
    /* 73 0x49 'I' */
    0x3c, /* 00111100 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x3c, /* 00111100 */
    0x00, /* 00000000 */
 
    /* 74 0x4a 'J' */
    0x1e, /* 00011110 */
    0x0c, /* 00001100 */
    0x0c, /* 00001100 */
    0x0c, /* 00001100 */
    0xcc, /* 11001100 */
    0xcc, /* 11001100 */
    0x78, /* 01111000 */
    0x00, /* 00000000 */
 
    /* 75 0x4b 'K' */
    0xe6, /* 11100110 */
    0x66, /* 01100110 */
    0x6c, /* 01101100 */
    0x78, /* 01111000 */
    0x6c, /* 01101100 */
    0x66, /* 01100110 */
    0xe6, /* 11100110 */
    0x00, /* 00000000 */
 
    /* 76 0x4c 'L' */
    0xf0, /* 11110000 */
    0x60, /* 01100000 */
    0x60, /* 01100000 */
    0x60, /* 01100000 */
    0x62, /* 01100010 */
    0x66, /* 01100110 */
    0xfe, /* 11111110 */
    0x00, /* 00000000 */
 
    /* 77 0x4d 'M' */
    0xc6, /* 11000110 */
    0xee, /* 11101110 */
    0xfe, /* 11111110 */
    0xfe, /* 11111110 */
    0xd6, /* 11010110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x00, /* 00000000 */
 
    /* 78 0x4e 'N' */
    0xc6, /* 11000110 */
    0xe6, /* 11100110 */
    0xf6, /* 11110110 */
    0xde, /* 11011110 */
    0xce, /* 11001110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x00, /* 00000000 */
 
    /* 79 0x4f 'O' */
    0x7c, /* 01111100 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x7c, /* 01111100 */
    0x00, /* 00000000 */
 
    /* 80 0x50 'P' */
    0xfc, /* 11111100 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x7c, /* 01111100 */
    0x60, /* 01100000 */
    0x60, /* 01100000 */
    0xf0, /* 11110000 */
    0x00, /* 00000000 */
 
    /* 81 0x51 'Q' */
    0x7c, /* 01111100 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xce, /* 11001110 */
    0x7c, /* 01111100 */
    0x0e, /* 00001110 */
 
    /* 82 0x52 'R' */
    0xfc, /* 11111100 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x7c, /* 01111100 */
    0x6c, /* 01101100 */
    0x66, /* 01100110 */
    0xe6, /* 11100110 */
    0x00, /* 00000000 */
 
    /* 83 0x53 'S' */
    0x3c, /* 00111100 */
    0x66, /* 01100110 */
    0x30, /* 00110000 */
    0x18, /* 00011000 */
    0x0c, /* 00001100 */
    0x66, /* 01100110 */
    0x3c, /* 00111100 */
    0x00, /* 00000000 */
 
    /* 84 0x54 'T' */
    0x7e, /* 01111110 */
    0x7e, /* 01111110 */
    0x5a, /* 01011010 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x3c, /* 00111100 */
    0x00, /* 00000000 */
 
    /* 85 0x55 'U' */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x7c, /* 01111100 */
    0x00, /* 00000000 */
 
    /* 86 0x56 'V' */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x6c, /* 01101100 */
    0x38, /* 00111000 */
    0x00, /* 00000000 */
 
    /* 87 0x57 'W' */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xd6, /* 11010110 */
    0xd6, /* 11010110 */
    0xfe, /* 11111110 */
    0x6c, /* 01101100 */
    0x00, /* 00000000 */
 
    /* 88 0x58 'X' */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x6c, /* 01101100 */
    0x38, /* 00111000 */
    0x6c, /* 01101100 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x00, /* 00000000 */
 
    /* 89 0x59 'Y' */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x3c, /* 00111100 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x3c, /* 00111100 */
    0x00, /* 00000000 */
 
    /* 90 0x5a 'Z' */
    0xfe, /* 11111110 */
    0xc6, /* 11000110 */
    0x8c, /* 10001100 */
    0x18, /* 00011000 */
    0x32, /* 00110010 */
    0x66, /* 01100110 */
    0xfe, /* 11111110 */
    0x00, /* 00000000 */
 
    /* 91 0x5b '[' */
    0x3c, /* 00111100 */
    0x30, /* 00110000 */
    0x30, /* 00110000 */
    0x30, /* 00110000 */
    0x30, /* 00110000 */
    0x30, /* 00110000 */
    0x3c, /* 00111100 */
    0x00, /* 00000000 */
 
    /* 92 0x5c '\' */
    0xc0, /* 11000000 */
    0x60, /* 01100000 */
    0x30, /* 00110000 */
    0x18, /* 00011000 */
    0x0c, /* 00001100 */
    0x06, /* 00000110 */
    0x02, /* 00000010 */
    0x00, /* 00000000 */
 
    /* 93 0x5d ']' */
    0x3c, /* 00111100 */
    0x0c, /* 00001100 */
    0x0c, /* 00001100 */
    0x0c, /* 00001100 */
    0x0c, /* 00001100 */
    0x0c, /* 00001100 */
    0x3c, /* 00111100 */
    0x00, /* 00000000 */
 
    /* 94 0x5e '^' */
    0x10, /* 00010000 */
    0x38, /* 00111000 */
    0x6c, /* 01101100 */
    0xc6, /* 11000110 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 95 0x5f '_' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xff, /* 11111111 */
 
    /* 96 0x60 '`' */
    0x30, /* 00110000 */
    0x18, /* 00011000 */
    0x0c, /* 00001100 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 97 0x61 'a' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x78, /* 01111000 */
    0x0c, /* 00001100 */
    0x7c, /* 01111100 */
    0xcc, /* 11001100 */
    0x76, /* 01110110 */
    0x00, /* 00000000 */
 
    /* 98 0x62 'b' */
    0xe0, /* 11100000 */
    0x60, /* 01100000 */
    0x7c, /* 01111100 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0xdc, /* 11011100 */
    0x00, /* 00000000 */
 
    /* 99 0x63 'c' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x7c, /* 01111100 */
    0xc6, /* 11000110 */
    0xc0, /* 11000000 */
    0xc6, /* 11000110 */
    0x7c, /* 01111100 */
    0x00, /* 00000000 */
 
    /* 100 0x64 'd' */
    0x1c, /* 00011100 */
    0x0c, /* 00001100 */
    0x7c, /* 01111100 */
    0xcc, /* 11001100 */
    0xcc, /* 11001100 */
    0xcc, /* 11001100 */
    0x76, /* 01110110 */
    0x00, /* 00000000 */
 
    /* 101 0x65 'e' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x7c, /* 01111100 */
    0xc6, /* 11000110 */
    0xfe, /* 11111110 */
    0xc0, /* 11000000 */
    0x7c, /* 01111100 */
    0x00, /* 00000000 */
 
    /* 102 0x66 'f' */
    0x3c, /* 00111100 */
    0x66, /* 01100110 */
    0x60, /* 01100000 */
    0xf8, /* 11111000 */
    0x60, /* 01100000 */
    0x60, /* 01100000 */
    0xf0, /* 11110000 */
    0x00, /* 00000000 */
 
    /* 103 0x67 'g' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x76, /* 01110110 */
    0xcc, /* 11001100 */
    0xcc, /* 11001100 */
    0x7c, /* 01111100 */
    0x0c, /* 00001100 */
    0xf8, /* 11111000 */
 
    /* 104 0x68 'h' */
    0xe0, /* 11100000 */
    0x60, /* 01100000 */
    0x6c, /* 01101100 */
    0x76, /* 01110110 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0xe6, /* 11100110 */
    0x00, /* 00000000 */
 
    /* 105 0x69 'i' */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
    0x38, /* 00111000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x3c, /* 00111100 */
    0x00, /* 00000000 */
 
    /* 106 0x6a 'j' */
    0x06, /* 00000110 */
    0x00, /* 00000000 */
    0x06, /* 00000110 */
    0x06, /* 00000110 */
    0x06, /* 00000110 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x3c, /* 00111100 */
 
    /* 107 0x6b 'k' */
    0xe0, /* 11100000 */
    0x60, /* 01100000 */
    0x66, /* 01100110 */
    0x6c, /* 01101100 */
    0x78, /* 01111000 */
    0x6c, /* 01101100 */
    0xe6, /* 11100110 */
    0x00, /* 00000000 */
 
    /* 108 0x6c 'l' */
    0x38, /* 00111000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x3c, /* 00111100 */
    0x00, /* 00000000 */
 
    /* 109 0x6d 'm' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xec, /* 11101100 */
    0xfe, /* 11111110 */
    0xd6, /* 11010110 */
    0xd6, /* 11010110 */
    0xd6, /* 11010110 */
    0x00, /* 00000000 */
 
    /* 110 0x6e 'n' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xdc, /* 11011100 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x00, /* 00000000 */
 
    /* 111 0x6f 'o' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x7c, /* 01111100 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x7c, /* 01111100 */
    0x00, /* 00000000 */
 
    /* 112 0x70 'p' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xdc, /* 11011100 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x7c, /* 01111100 */
    0x60, /* 01100000 */
    0xf0, /* 11110000 */
 
    /* 113 0x71 'q' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x76, /* 01110110 */
    0xcc, /* 11001100 */
    0xcc, /* 11001100 */
    0x7c, /* 01111100 */
    0x0c, /* 00001100 */
    0x1e, /* 00011110 */
 
    /* 114 0x72 'r' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xdc, /* 11011100 */
    0x76, /* 01110110 */
    0x60, /* 01100000 */
    0x60, /* 01100000 */
    0xf0, /* 11110000 */
    0x00, /* 00000000 */
 
    /* 115 0x73 's' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x7e, /* 01111110 */
    0xc0, /* 11000000 */
    0x7c, /* 01111100 */
    0x06, /* 00000110 */
    0xfc, /* 11111100 */
    0x00, /* 00000000 */
 
    /* 116 0x74 't' */
    0x30, /* 00110000 */
    0x30, /* 00110000 */
    0xfc, /* 11111100 */
    0x30, /* 00110000 */
    0x30, /* 00110000 */
    0x36, /* 00110110 */
    0x1c, /* 00011100 */
    0x00, /* 00000000 */
 
    /* 117 0x75 'u' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xcc, /* 11001100 */
    0xcc, /* 11001100 */
    0xcc, /* 11001100 */
    0xcc, /* 11001100 */
    0x76, /* 01110110 */
    0x00, /* 00000000 */
 
    /* 118 0x76 'v' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x6c, /* 01101100 */
    0x38, /* 00111000 */
    0x00, /* 00000000 */
 
    /* 119 0x77 'w' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xc6, /* 11000110 */
    0xd6, /* 11010110 */
    0xd6, /* 11010110 */
    0xfe, /* 11111110 */
    0x6c, /* 01101100 */
    0x00, /* 00000000 */
 
    /* 120 0x78 'x' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xc6, /* 11000110 */
    0x6c, /* 01101100 */
    0x38, /* 00111000 */
    0x6c, /* 01101100 */
    0xc6, /* 11000110 */
    0x00, /* 00000000 */
 
    /* 121 0x79 'y' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x7e, /* 01111110 */
    0x06, /* 00000110 */
    0xfc, /* 11111100 */
 
    /* 122 0x7a 'z' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x7e, /* 01111110 */
    0x4c, /* 01001100 */
    0x18, /* 00011000 */
    0x32, /* 00110010 */
    0x7e, /* 01111110 */
    0x00, /* 00000000 */
 
    /* 123 0x7b '{' */
    0x0e, /* 00001110 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x70, /* 01110000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x0e, /* 00001110 */
    0x00, /* 00000000 */
 
    /* 124 0x7c '|' */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
 
    /* 125 0x7d '}' */
    0x70, /* 01110000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x0e, /* 00001110 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x70, /* 01110000 */
    0x00, /* 00000000 */
 
    /* 126 0x7e '~' */
    0x76, /* 01110110 */
    0xdc, /* 11011100 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 127 0x7f '' */
    0x00, /* 00000000 */
    0x10, /* 00010000 */
    0x38, /* 00111000 */
    0x6c, /* 01101100 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xfe, /* 11111110 */
    0x00, /* 00000000 */
 
    /* 128 0x80 '€' */
    0x7c, /* 01111100 */
    0xc6, /* 11000110 */
    0xc0, /* 11000000 */
    0xc0, /* 11000000 */
    0xc6, /* 11000110 */
    0x7c, /* 01111100 */
    0x0c, /* 00001100 */
    0x78, /* 01111000 */
 
    /* 129 0x81 ' ' */
    0xcc, /* 11001100 */
    0x00, /* 00000000 */
    0xcc, /* 11001100 */
    0xcc, /* 11001100 */
    0xcc, /* 11001100 */
    0xcc, /* 11001100 */
    0x76, /* 01110110 */
    0x00, /* 00000000 */
 
    /* 130 0x82 '?' */
    0x0c, /* 00001100 */
    0x18, /* 00011000 */
    0x7c, /* 01111100 */
    0xc6, /* 11000110 */
    0xfe, /* 11111110 */
    0xc0, /* 11000000 */
    0x7c, /* 01111100 */
    0x00, /* 00000000 */
 
    /* 131 0x83 '?' */
    0x7c, /* 01111100 */
    0x82, /* 10000010 */
    0x78, /* 01111000 */
    0x0c, /* 00001100 */
    0x7c, /* 01111100 */
    0xcc, /* 11001100 */
    0x76, /* 01110110 */
    0x00, /* 00000000 */
 
    /* 132 0x84 '?' */
    0xc6, /* 11000110 */
    0x00, /* 00000000 */
    0x78, /* 01111000 */
    0x0c, /* 00001100 */
    0x7c, /* 01111100 */
    0xcc, /* 11001100 */
    0x76, /* 01110110 */
    0x00, /* 00000000 */
 
    /* 133 0x85 '…' */
    0x30, /* 00110000 */
    0x18, /* 00011000 */
    0x78, /* 01111000 */
    0x0c, /* 00001100 */
    0x7c, /* 01111100 */
    0xcc, /* 11001100 */
    0x76, /* 01110110 */
    0x00, /* 00000000 */
 
    /* 134 0x86 '†' */
    0x30, /* 00110000 */
    0x30, /* 00110000 */
    0x78, /* 01111000 */
    0x0c, /* 00001100 */
    0x7c, /* 01111100 */
    0xcc, /* 11001100 */
    0x76, /* 01110110 */
    0x00, /* 00000000 */
 
    /* 135 0x87 '‡' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x7e, /* 01111110 */
    0xc0, /* 11000000 */
    0xc0, /* 11000000 */
    0x7e, /* 01111110 */
    0x0c, /* 00001100 */
    0x38, /* 00111000 */
 
    /* 136 0x88 '?' */
    0x7c, /* 01111100 */
    0x82, /* 10000010 */
    0x7c, /* 01111100 */
    0xc6, /* 11000110 */
    0xfe, /* 11111110 */
    0xc0, /* 11000000 */
    0x7c, /* 01111100 */
    0x00, /* 00000000 */
 
    /* 137 0x89 '‰' */
    0xc6, /* 11000110 */
    0x00, /* 00000000 */
    0x7c, /* 01111100 */
    0xc6, /* 11000110 */
    0xfe, /* 11111110 */
    0xc0, /* 11000000 */
    0x7c, /* 01111100 */
    0x00, /* 00000000 */
 
    /* 138 0x8a '?' */
    0x30, /* 00110000 */
    0x18, /* 00011000 */
    0x7c, /* 01111100 */
    0xc6, /* 11000110 */
    0xfe, /* 11111110 */
    0xc0, /* 11000000 */
    0x7c, /* 01111100 */
    0x00, /* 00000000 */
 
    /* 139 0x8b '?' */
    0x66, /* 01100110 */
    0x00, /* 00000000 */
    0x38, /* 00111000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x3c, /* 00111100 */
    0x00, /* 00000000 */
 
    /* 140 0x8c 'Œ' */
    0x7c, /* 01111100 */
    0x82, /* 10000010 */
    0x38, /* 00111000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x3c, /* 00111100 */
    0x00, /* 00000000 */
 
    /* 141 0x8d ' ' */
    0x30, /* 00110000 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
    0x38, /* 00111000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x3c, /* 00111100 */
    0x00, /* 00000000 */
 
    /* 142 0x8e '?' */
    0xc6, /* 11000110 */
    0x38, /* 00111000 */
    0x6c, /* 01101100 */
    0xc6, /* 11000110 */
    0xfe, /* 11111110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x00, /* 00000000 */
 
    /* 143 0x8f ' ' */
    0x38, /* 00111000 */
    0x6c, /* 01101100 */
    0x7c, /* 01111100 */
    0xc6, /* 11000110 */
    0xfe, /* 11111110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x00, /* 00000000 */
 
    /* 144 0x90 ' ' */
    0x18, /* 00011000 */
    0x30, /* 00110000 */
    0xfe, /* 11111110 */
    0xc0, /* 11000000 */
    0xf8, /* 11111000 */
    0xc0, /* 11000000 */
    0xfe, /* 11111110 */
    0x00, /* 00000000 */
 
    /* 145 0x91 '‘' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x7e, /* 01111110 */
    0x18, /* 00011000 */
    0x7e, /* 01111110 */
    0xd8, /* 11011000 */
    0x7e, /* 01111110 */
    0x00, /* 00000000 */
 
    /* 146 0x92 '’' */
    0x3e, /* 00111110 */
    0x6c, /* 01101100 */
    0xcc, /* 11001100 */
    0xfe, /* 11111110 */
    0xcc, /* 11001100 */
    0xcc, /* 11001100 */
    0xce, /* 11001110 */
    0x00, /* 00000000 */
 
    /* 147 0x93 '“' */
    0x7c, /* 01111100 */
    0x82, /* 10000010 */
    0x7c, /* 01111100 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x7c, /* 01111100 */
    0x00, /* 00000000 */
 
    /* 148 0x94 '”' */
    0xc6, /* 11000110 */
    0x00, /* 00000000 */
    0x7c, /* 01111100 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x7c, /* 01111100 */
    0x00, /* 00000000 */
 
    /* 149 0x95 '?' */
    0x30, /* 00110000 */
    0x18, /* 00011000 */
    0x7c, /* 01111100 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x7c, /* 01111100 */
    0x00, /* 00000000 */
 
    /* 150 0x96 '?' */
    0x78, /* 01111000 */
    0x84, /* 10000100 */
    0x00, /* 00000000 */
    0xcc, /* 11001100 */
    0xcc, /* 11001100 */
    0xcc, /* 11001100 */
    0x76, /* 01110110 */
    0x00, /* 00000000 */
 
    /* 151 0x97 '?' */
    0x60, /* 01100000 */
    0x30, /* 00110000 */
    0xcc, /* 11001100 */
    0xcc, /* 11001100 */
    0xcc, /* 11001100 */
    0xcc, /* 11001100 */
    0x76, /* 01110110 */
    0x00, /* 00000000 */
 
    /* 152 0x98 '?' */
    0xc6, /* 11000110 */
    0x00, /* 00000000 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x7e, /* 01111110 */
    0x06, /* 00000110 */
    0xfc, /* 11111100 */
 
    /* 153 0x99 '™' */
    0xc6, /* 11000110 */
    0x38, /* 00111000 */
    0x6c, /* 01101100 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x6c, /* 01101100 */
    0x38, /* 00111000 */
    0x00, /* 00000000 */
 
    /* 154 0x9a '?' */
    0xc6, /* 11000110 */
    0x00, /* 00000000 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x7c, /* 01111100 */
    0x00, /* 00000000 */
 
    /* 155 0x9b '?' */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x7e, /* 01111110 */
    0xc0, /* 11000000 */
    0xc0, /* 11000000 */
    0x7e, /* 01111110 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
 
    /* 156 0x9c 'œ' */
    0x38, /* 00111000 */
    0x6c, /* 01101100 */
    0x64, /* 01100100 */
    0xf0, /* 11110000 */
    0x60, /* 01100000 */
    0x66, /* 01100110 */
    0xfc, /* 11111100 */
    0x00, /* 00000000 */
 
    /* 157 0x9d ' ' */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x3c, /* 00111100 */
    0x7e, /* 01111110 */
    0x18, /* 00011000 */
    0x7e, /* 01111110 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
 
    /* 158 0x9e '?' */
    0xf8, /* 11111000 */
    0xcc, /* 11001100 */
    0xcc, /* 11001100 */
    0xfa, /* 11111010 */
    0xc6, /* 11000110 */
    0xcf, /* 11001111 */
    0xc6, /* 11000110 */
    0xc7, /* 11000111 */
 
    /* 159 0x9f '?' */
    0x0e, /* 00001110 */
    0x1b, /* 00011011 */
    0x18, /* 00011000 */
    0x3c, /* 00111100 */
    0x18, /* 00011000 */
    0xd8, /* 11011000 */
    0x70, /* 01110000 */
    0x00, /* 00000000 */
 
    /* 160 0xa0 ' ' */
    0x18, /* 00011000 */
    0x30, /* 00110000 */
    0x78, /* 01111000 */
    0x0c, /* 00001100 */
    0x7c, /* 01111100 */
    0xcc, /* 11001100 */
    0x76, /* 01110110 */
    0x00, /* 00000000 */
 
    /* 161 0xa1 '¡' */
    0x0c, /* 00001100 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
    0x38, /* 00111000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x3c, /* 00111100 */
    0x00, /* 00000000 */
 
    /* 162 0xa2 '￠' */
    0x0c, /* 00001100 */
    0x18, /* 00011000 */
    0x7c, /* 01111100 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x7c, /* 01111100 */
    0x00, /* 00000000 */
 
    /* 163 0xa3 '￡' */
    0x18, /* 00011000 */
    0x30, /* 00110000 */
    0xcc, /* 11001100 */
    0xcc, /* 11001100 */
    0xcc, /* 11001100 */
    0xcc, /* 11001100 */
    0x76, /* 01110110 */
    0x00, /* 00000000 */
 
    /* 164 0xa4 '¤' */
    0x76, /* 01110110 */
    0xdc, /* 11011100 */
    0x00, /* 00000000 */
    0xdc, /* 11011100 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x00, /* 00000000 */
 
    /* 165 0xa5 '￥' */
    0x76, /* 01110110 */
    0xdc, /* 11011100 */
    0x00, /* 00000000 */
    0xe6, /* 11100110 */
    0xf6, /* 11110110 */
    0xde, /* 11011110 */
    0xce, /* 11001110 */
    0x00, /* 00000000 */
 
    /* 166 0xa6 '|' */
    0x3c, /* 00111100 */
    0x6c, /* 01101100 */
    0x6c, /* 01101100 */
    0x3e, /* 00111110 */
    0x00, /* 00000000 */
    0x7e, /* 01111110 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 167 0xa7 '§' */
    0x38, /* 00111000 */
    0x6c, /* 01101100 */
    0x6c, /* 01101100 */
    0x38, /* 00111000 */
    0x00, /* 00000000 */
    0x7c, /* 01111100 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 168 0xa8 '¨' */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x30, /* 00110000 */
    0x63, /* 01100011 */
    0x3e, /* 00111110 */
    0x00, /* 00000000 */
 
    /* 169 0xa9 'ⓒ' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xfe, /* 11111110 */
    0xc0, /* 11000000 */
    0xc0, /* 11000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 170 0xaa 'ª' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xfe, /* 11111110 */
    0x06, /* 00000110 */
    0x06, /* 00000110 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 171 0xab '≪' */
    0x63, /* 01100011 */
    0xe6, /* 11100110 */
    0x6c, /* 01101100 */
    0x7e, /* 01111110 */
    0x33, /* 00110011 */
    0x66, /* 01100110 */
    0xcc, /* 11001100 */
    0x0f, /* 00001111 */
 
    /* 172 0xac '￢' */
    0x63, /* 01100011 */
    0xe6, /* 11100110 */
    0x6c, /* 01101100 */
    0x7a, /* 01111010 */
    0x36, /* 00110110 */
    0x6a, /* 01101010 */
    0xdf, /* 11011111 */
    0x06, /* 00000110 */
 
    /* 173 0xad ' ' */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x3c, /* 00111100 */
    0x3c, /* 00111100 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
 
    /* 174 0xae '®' */
    0x00, /* 00000000 */
    0x33, /* 00110011 */
    0x66, /* 01100110 */
    0xcc, /* 11001100 */
    0x66, /* 01100110 */
    0x33, /* 00110011 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 175 0xaf '?' */
    0x00, /* 00000000 */
    0xcc, /* 11001100 */
    0x66, /* 01100110 */
    0x33, /* 00110011 */
    0x66, /* 01100110 */
    0xcc, /* 11001100 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 176 0xb0 '°' */
    0x22, /* 00100010 */
    0x88, /* 10001000 */
    0x22, /* 00100010 */
    0x88, /* 10001000 */
    0x22, /* 00100010 */
    0x88, /* 10001000 */
    0x22, /* 00100010 */
    0x88, /* 10001000 */
 
    /* 177 0xb1 '±' */
    0x55, /* 01010101 */
    0xaa, /* 10101010 */
    0x55, /* 01010101 */
    0xaa, /* 10101010 */
    0x55, /* 01010101 */
    0xaa, /* 10101010 */
    0x55, /* 01010101 */
    0xaa, /* 10101010 */
 
    /* 178 0xb2 '²' */
    0x77, /* 01110111 */
    0xdd, /* 11011101 */
    0x77, /* 01110111 */
    0xdd, /* 11011101 */
    0x77, /* 01110111 */
    0xdd, /* 11011101 */
    0x77, /* 01110111 */
    0xdd, /* 11011101 */
 
    /* 179 0xb3 '³' */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
 
    /* 180 0xb4 '´' */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0xf8, /* 11111000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
 
    /* 181 0xb5 'μ' */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0xf8, /* 11111000 */
    0x18, /* 00011000 */
    0xf8, /* 11111000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
 
    /* 182 0xb6 '¶' */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0xf6, /* 11110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
 
    /* 183 0xb7 '·' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xfe, /* 11111110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
 
    /* 184 0xb8 '¸' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xf8, /* 11111000 */
    0x18, /* 00011000 */
    0xf8, /* 11111000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
 
    /* 185 0xb9 '¹' */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0xf6, /* 11110110 */
    0x06, /* 00000110 */
    0xf6, /* 11110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
 
    /* 186 0xba 'º' */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
 
    /* 187 0xbb '≫' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xfe, /* 11111110 */
    0x06, /* 00000110 */
    0xf6, /* 11110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
 
    /* 188 0xbc '¼' */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0xf6, /* 11110110 */
    0x06, /* 00000110 */
    0xfe, /* 11111110 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 189 0xbd '½' */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0xfe, /* 11111110 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 190 0xbe '¾' */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0xf8, /* 11111000 */
    0x18, /* 00011000 */
    0xf8, /* 11111000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 191 0xbf '¿' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xf8, /* 11111000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
 
    /* 192 0xc0 'A' */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x1f, /* 00011111 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 193 0xc1 'A' */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0xff, /* 11111111 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 194 0xc2 'A' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xff, /* 11111111 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
 
    /* 195 0xc3 'A' */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x1f, /* 00011111 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
 
    /* 196 0xc4 'A' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xff, /* 11111111 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 197 0xc5 'A' */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0xff, /* 11111111 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
 
    /* 198 0xc6 'Æ' */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x1f, /* 00011111 */
    0x18, /* 00011000 */
    0x1f, /* 00011111 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
 
    /* 199 0xc7 'C' */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x37, /* 00110111 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
 
    /* 200 0xc8 'E' */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x37, /* 00110111 */
    0x30, /* 00110000 */
    0x3f, /* 00111111 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 201 0xc9 'E' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x3f, /* 00111111 */
    0x30, /* 00110000 */
    0x37, /* 00110111 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
 
    /* 202 0xca 'E' */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0xf7, /* 11110111 */
    0x00, /* 00000000 */
    0xff, /* 11111111 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 203 0xcb 'E' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xff, /* 11111111 */
    0x00, /* 00000000 */
    0xf7, /* 11110111 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
 
    /* 204 0xcc 'I' */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x37, /* 00110111 */
    0x30, /* 00110000 */
    0x37, /* 00110111 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
 
    /* 205 0xcd 'I' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xff, /* 11111111 */
    0x00, /* 00000000 */
    0xff, /* 11111111 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 206 0xce 'I' */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0xf7, /* 11110111 */
    0x00, /* 00000000 */
    0xf7, /* 11110111 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
 
    /* 207 0xcf 'I' */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0xff, /* 11111111 */
    0x00, /* 00000000 */
    0xff, /* 11111111 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 208 0xd0 'Ð' */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0xff, /* 11111111 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 209 0xd1 'N' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xff, /* 11111111 */
    0x00, /* 00000000 */
    0xff, /* 11111111 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
 
    /* 210 0xd2 'O' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xff, /* 11111111 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
 
    /* 211 0xd3 'O' */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x3f, /* 00111111 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 212 0xd4 'O' */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x1f, /* 00011111 */
    0x18, /* 00011000 */
    0x1f, /* 00011111 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 213 0xd5 'O' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x1f, /* 00011111 */
    0x18, /* 00011000 */
    0x1f, /* 00011111 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
 
    /* 214 0xd6 'O' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x3f, /* 00111111 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
 
    /* 215 0xd7 '×' */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0xff, /* 11111111 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
 
    /* 216 0xd8 'Ø' */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0xff, /* 11111111 */
    0x18, /* 00011000 */
    0xff, /* 11111111 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
 
    /* 217 0xd9 'U' */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0xf8, /* 11111000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 218 0xda 'U' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x1f, /* 00011111 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
 
    /* 219 0xdb 'U' */
    0xff, /* 11111111 */
    0xff, /* 11111111 */
    0xff, /* 11111111 */
    0xff, /* 11111111 */
    0xff, /* 11111111 */
    0xff, /* 11111111 */
    0xff, /* 11111111 */
    0xff, /* 11111111 */
 
    /* 220 0xdc 'U' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xff, /* 11111111 */
    0xff, /* 11111111 */
    0xff, /* 11111111 */
    0xff, /* 11111111 */
 
    /* 221 0xdd 'Y' */
    0xf0, /* 11110000 */
    0xf0, /* 11110000 */
    0xf0, /* 11110000 */
    0xf0, /* 11110000 */
    0xf0, /* 11110000 */
    0xf0, /* 11110000 */
    0xf0, /* 11110000 */
    0xf0, /* 11110000 */
 
    /* 222 0xde 'Þ' */
    0x0f, /* 00001111 */
    0x0f, /* 00001111 */
    0x0f, /* 00001111 */
    0x0f, /* 00001111 */
    0x0f, /* 00001111 */
    0x0f, /* 00001111 */
    0x0f, /* 00001111 */
    0x0f, /* 00001111 */
 
    /* 223 0xdf 'ß' */
    0xff, /* 11111111 */
    0xff, /* 11111111 */
    0xff, /* 11111111 */
    0xff, /* 11111111 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 224 0xe0 'a' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x76, /* 01110110 */
    0xdc, /* 11011100 */
    0xc8, /* 11001000 */
    0xdc, /* 11011100 */
    0x76, /* 01110110 */
    0x00, /* 00000000 */
 
    /* 225 0xe1 'a' */
    0x78, /* 01111000 */
    0xcc, /* 11001100 */
    0xcc, /* 11001100 */
    0xd8, /* 11011000 */
    0xcc, /* 11001100 */
    0xc6, /* 11000110 */
    0xcc, /* 11001100 */
    0x00, /* 00000000 */
 
    /* 226 0xe2 'a' */
    0xfe, /* 11111110 */
    0xc6, /* 11000110 */
    0xc0, /* 11000000 */
    0xc0, /* 11000000 */
    0xc0, /* 11000000 */
    0xc0, /* 11000000 */
    0xc0, /* 11000000 */
    0x00, /* 00000000 */
 
    /* 227 0xe3 'a' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0xfe, /* 11111110 */
    0x6c, /* 01101100 */
    0x6c, /* 01101100 */
    0x6c, /* 01101100 */
    0x6c, /* 01101100 */
    0x00, /* 00000000 */
 
    /* 228 0xe4 'a' */
    0xfe, /* 11111110 */
    0xc6, /* 11000110 */
    0x60, /* 01100000 */
    0x30, /* 00110000 */
    0x60, /* 01100000 */
    0xc6, /* 11000110 */
    0xfe, /* 11111110 */
    0x00, /* 00000000 */
 
    /* 229 0xe5 'a' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x7e, /* 01111110 */
    0xd8, /* 11011000 */
    0xd8, /* 11011000 */
    0xd8, /* 11011000 */
    0x70, /* 01110000 */
    0x00, /* 00000000 */
 
    /* 230 0xe6 'æ' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x7c, /* 01111100 */
    0xc0, /* 11000000 */
 
    /* 231 0xe7 'c' */
    0x00, /* 00000000 */
    0x76, /* 01110110 */
    0xdc, /* 11011100 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
 
    /* 232 0xe8 'e' */
    0x7e, /* 01111110 */
    0x18, /* 00011000 */
    0x3c, /* 00111100 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x3c, /* 00111100 */
    0x18, /* 00011000 */
    0x7e, /* 01111110 */
 
    /* 233 0xe9 'e' */
    0x38, /* 00111000 */
    0x6c, /* 01101100 */
    0xc6, /* 11000110 */
    0xfe, /* 11111110 */
    0xc6, /* 11000110 */
    0x6c, /* 01101100 */
    0x38, /* 00111000 */
    0x00, /* 00000000 */
 
    /* 234 0xea 'e' */
    0x38, /* 00111000 */
    0x6c, /* 01101100 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x6c, /* 01101100 */
    0x6c, /* 01101100 */
    0xee, /* 11101110 */
    0x00, /* 00000000 */
 
    /* 235 0xeb 'e' */
    0x0e, /* 00001110 */
    0x18, /* 00011000 */
    0x0c, /* 00001100 */
    0x3e, /* 00111110 */
    0x66, /* 01100110 */
    0x66, /* 01100110 */
    0x3c, /* 00111100 */
    0x00, /* 00000000 */
 
    /* 236 0xec 'i' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x7e, /* 01111110 */
    0xdb, /* 11011011 */
    0xdb, /* 11011011 */
    0x7e, /* 01111110 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 237 0xed 'i' */
    0x06, /* 00000110 */
    0x0c, /* 00001100 */
    0x7e, /* 01111110 */
    0xdb, /* 11011011 */
    0xdb, /* 11011011 */
    0x7e, /* 01111110 */
    0x60, /* 01100000 */
    0xc0, /* 11000000 */
 
    /* 238 0xee 'i' */
    0x1e, /* 00011110 */
    0x30, /* 00110000 */
    0x60, /* 01100000 */
    0x7e, /* 01111110 */
    0x60, /* 01100000 */
    0x30, /* 00110000 */
    0x1e, /* 00011110 */
    0x00, /* 00000000 */
 
    /* 239 0xef 'i' */
    0x00, /* 00000000 */
    0x7c, /* 01111100 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0xc6, /* 11000110 */
    0x00, /* 00000000 */
 
    /* 240 0xf0 'ð' */
    0x00, /* 00000000 */
    0xfe, /* 11111110 */
    0x00, /* 00000000 */
    0xfe, /* 11111110 */
    0x00, /* 00000000 */
    0xfe, /* 11111110 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 241 0xf1 'n' */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x7e, /* 01111110 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
    0x7e, /* 01111110 */
    0x00, /* 00000000 */
 
    /* 242 0xf2 'o' */
    0x30, /* 00110000 */
    0x18, /* 00011000 */
    0x0c, /* 00001100 */
    0x18, /* 00011000 */
    0x30, /* 00110000 */
    0x00, /* 00000000 */
    0x7e, /* 01111110 */
    0x00, /* 00000000 */
 
    /* 243 0xf3 'o' */
    0x0c, /* 00001100 */
    0x18, /* 00011000 */
    0x30, /* 00110000 */
    0x18, /* 00011000 */
    0x0c, /* 00001100 */
    0x00, /* 00000000 */
    0x7e, /* 01111110 */
    0x00, /* 00000000 */
 
    /* 244 0xf4 'o' */
    0x0e, /* 00001110 */
    0x1b, /* 00011011 */
    0x1b, /* 00011011 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
 
    /* 245 0xf5 'o' */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0xd8, /* 11011000 */
    0xd8, /* 11011000 */
    0x70, /* 01110000 */
 
    /* 246 0xf6 'o' */
    0x00, /* 00000000 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
    0x7e, /* 01111110 */
    0x00, /* 00000000 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 247 0xf7 '÷' */
    0x00, /* 00000000 */
    0x76, /* 01110110 */
    0xdc, /* 11011100 */
    0x00, /* 00000000 */
    0x76, /* 01110110 */
    0xdc, /* 11011100 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 248 0xf8 'ø' */
    0x38, /* 00111000 */
    0x6c, /* 01101100 */
    0x6c, /* 01101100 */
    0x38, /* 00111000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 249 0xf9 'u' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x18, /* 00011000 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 250 0xfa 'u' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x18, /* 00011000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 251 0xfb 'u' */
    0x0f, /* 00001111 */
    0x0c, /* 00001100 */
    0x0c, /* 00001100 */
    0x0c, /* 00001100 */
    0xec, /* 11101100 */
    0x6c, /* 01101100 */
    0x3c, /* 00111100 */
    0x1c, /* 00011100 */
 
    /* 252 0xfc 'u' */
    0x6c, /* 01101100 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x36, /* 00110110 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 253 0xfd 'y' */
    0x78, /* 01111000 */
    0x0c, /* 00001100 */
    0x18, /* 00011000 */
    0x30, /* 00110000 */
    0x7c, /* 01111100 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 254 0xfe 'þ' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x3c, /* 00111100 */
    0x3c, /* 00111100 */
    0x3c, /* 00111100 */
    0x3c, /* 00111100 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
    /* 255 0xff 'y' */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
    0x00, /* 00000000 */
 
};
 
----------------------drawing.c--------------------------------

 
#include <stdio.h>
#include <stdbool.h>
 
#include "util.h"
#include "drawing.h"
#include "font_8x8.h"
 
#ifdef DEBUG_ENABLE
    #define DBGLOG(fmt,args...) fprintf(stderr, fmt "\n",##args)
#else
    #define DBGLOG(fmt,args...)
#endif
 
typedef struct _DrawColor
{
    uint8_t b;
    uint8_t g;
    uint8_t r;
    uint8_t a;
} DrawColor;
 
static bool get_char_pixel(char c, uint32_t x, uint32_t y)
{
    uint8_t bits = fontdata_8x8[8 * c + y];
    bool bit = (bits >> (7 - x)) & 1;
 
    return bit;
}
 
static uint32_t rgb888(DrawColor* pColor)
{
    return (pColor->r << 16) | (pColor->g << 8) | (pColor->b << 0);
}
 
static uint32_t bgr888(DrawColor* pColor)
{
    return (pColor->b << 16) | (pColor->g << 8) | (pColor->r << 0);
}
 
static uint32_t argb8888(DrawColor* pColor)
{
    return (pColor->a << 24) | (pColor->r << 16) | (pColor->g << 8) | (pColor->b << 0);
}
 
static uint32_t abgr8888(DrawColor* pColor)
{
    return (pColor->a << 24) | (pColor->b << 16) | (pColor->g << 8) | (pColor->r << 0);
}
 
static uint32_t rgba8888(DrawColor* pColor)
{
    return (pColor->r << 24) | (pColor->g << 16) | (pColor->b << 8) | (pColor->a << 24);
}
 
static uint32_t bgra8888(DrawColor* pColor)
{
    return (pColor->b << 24) | (pColor->g << 16) | (pColor->r << 8) | (pColor->a << 0);
}
 
static uint16_t rgb565(DrawColor* pColor)
{
    return ((pColor->r >> 3) << 11) | ((pColor->g >> 2) << 5) | ((pColor->b >> 3) << 0);
}
 
static uint16_t bgr565(DrawColor* pColor)
{
    return ((pColor->b >> 3) << 11) | ((pColor->g >> 2) << 5) | ((pColor->r >> 3) << 0);
}
 
 
/**
  * @brief  Get pixel format
  * @param  fourcc: color format of FOURCC type
  * @retval The enum value of the PixelFormat
  */
PixelFormat draw_get_pixel_foramt(int fourcc)
{
    PixelFormat format;
 
    switch(fourcc) {
        case FOURCC('R','G','1','6') :
            format = FORMAT_RGB565;
            break;
        case FOURCC('B','G','1','6') :
            format = FORMAT_BGR565;
            break;
        case FOURCC('R','G','2','4'):
            format = FORMAT_RGB888;
            break;
        case FOURCC('B','G','2','4'):
            format = FORMAT_BGR888;
            break;
 
        case FOURCC('A','R','2','4'):
            format = FORMAT_ARGB8888;
            break;
 
        case FOURCC('A','B','2','4'):
            format = FORMAT_ABGR8888;
            break;
 
        case FOURCC('R','A','2','4'):
            format = FORMAT_RGBA8888;
            break;
 
        case FOURCC('R','B','2','4'):
            format = FORMAT_BGRA8888;
            break;
 
        case FOURCC('U','Y','V','Y'):
        case FOURCC('Y','U','Y','V'):
        case FOURCC('N','V','1','2'):
        case FOURCC('I','4','2','0'):
            fprintf(stderr, "ERROR: %s not yet support!\n", __func__);
            format = FORMAT_MAX;
            break;
 
        default :
            fprintf(stderr, "ERROR: %s Invalid param\n", __func__);
            format = FORMAT_MAX;
            break;
    }
 
    DBGLOG("[%s] get pixel format:%d", __func__, format);
 
    return format;
}
 
/**
  * @brief  Draw a pixel to frame buffer
  * @param  pFrame: pointer to parameter of FrameBuffer structure
                 px : x position of the pixel
                 py : y position of the pixel
                 color : color format(PixelFormat) of the pixel. 
  * @retval The enum value of the PixelFormat
  */
void drawPixel(FrameBuffer* pFrame, uint32_t px, uint32_t py, uint32_t color)
{
    DrawColor RgbColor;
 
    RgbColor.a = (color >> 24 & 0xff);
    RgbColor.r = (color >> 16 & 0xff);
    RgbColor.g = (color >> 8 & 0xff);
    RgbColor.b = (color & 0xff);
 
    if(pFrame == NULL) {
        ERROR("Invalid param");
        return;
    }
 
    switch (pFrame->format) {
        case FORMAT_ARGB8888:
        {
            uint32_t *p = (uint32_t*)(pFrame->buf + pFrame->stride * py + px * 4);
            *p = color;//argb8888(&RgbColor);
            break;
        }
        case FORMAT_ABGR8888:
        {
            uint32_t *p = (uint32_t*)(pFrame->buf + pFrame->stride * py + px * 4);
            *p = abgr8888(&RgbColor);
            break;
        }
        case FORMAT_RGBA8888:
        {
            uint32_t *p = (uint32_t*)(pFrame->buf + pFrame->stride * py + px * 4);
            *p = rgba8888(&RgbColor);
            break;
        }
        case FORMAT_BGRA8888:
        {
            uint32_t *p = (uint32_t*)(pFrame->buf + pFrame->stride * py + px * 4);
            *p = bgra8888(&RgbColor);
            break;
        }
 
        case FORMAT_RGB888:
        {
            uint8_t *p = pFrame->buf + pFrame->stride * py + px * 3;
            p[0] = RgbColor.b;
            p[1] = RgbColor.g;
            p[2] = RgbColor.r;
            break;
        }
        case FORMAT_BGR888:
        {
            uint8_t *p = pFrame->buf + pFrame->stride * py + px * 3;
            p[0] = RgbColor.r;
            p[1] = RgbColor.g;
            p[2] = RgbColor.b;
            break;
        }
        case FORMAT_RGB565:
        {
            uint16_t *p = (uint16_t*)(pFrame->buf + pFrame->stride * py + px * 2);
            *p = rgb565(&RgbColor);
            break;
        }
        case FORMAT_BGR565:
        {
            uint16_t *p = (uint16_t*)(pFrame->buf + pFrame->stride * py + px * 2);
            *p = bgr565(&RgbColor);
            break;
        }
 
        default :
            ERROR("Invalid param");
            break;
    }
}
 
/**
  * @brief  Draw a rectangle to frame buffer
  * @param  pFrame: pointer to parameter of FrameBuffer structure
                 startx : start position of x axis for the rectangle
                 starty : start position of y axis for the rectangle
                 w : width of the rectangle
                 h : height of the rectangle
                 color : color format(PixelFormat) of the rectangle. 
  * @retval none
  */
void drawRect(FrameBuffer* pFrame, uint32_t startx, uint32_t starty, uint32_t w, uint32_t h, uint32_t color)
{
    unsigned i, j;
 
    if(pFrame == NULL) {
        ERROR("Invalid param");
        return;
    }
 
    DBGLOG("[%s] xpos:%d ypos:%d, stride:%d", __func__, startx, starty, pFrame->stride);
    DBGLOG("[%s] format:%d color:0x%08x", __func__, pFrame->format, color);
 
    switch (pFrame->format) {
        case FORMAT_BGR565 :
        case FORMAT_RGB565 :
        case FORMAT_BGR888 :
        case FORMAT_RGB888 :
        case FORMAT_ABGR8888 :
        case FORMAT_ARGB8888 :
        case FORMAT_BGRA8888 :
        case FORMAT_RGBA8888 :
            for (j = 0; j < h; j++) {
                for (i = 0; i < w; i++) {
                    drawPixel(pFrame, startx + i, starty + j, color);
                }
            }
            break;
 
        default :
            ERROR("Invalid param");
            break;
    }
}
 
/**
  * @brief  Draw a line to frame buffer
  * @param  pFrame: pointer to parameter of FrameBuffer structure
                 x1 : start position of x axis for the line
                 y1 : start position of y axis for the line
                 x2 : end position of x axis for the line
                 y2 : end position of y axis for the line
                 color : color format(PixelFormat) of the line. 
  * @retval none
  */
void drawLine(FrameBuffer* pFrame, uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2, uint32_t color)
{
    int i,dx,dy,sdx,sdy,dxabs,dyabs,x,y,px,py;
 
    if(pFrame == NULL) {
        ERROR("Invalid param");
        return;
    }
 
    switch (pFrame->format) {
        case FORMAT_BGR565 :
        case FORMAT_RGB565 :
        case FORMAT_BGR888 :
        case FORMAT_RGB888 :
        case FORMAT_ABGR8888 :
        case FORMAT_ARGB8888 :
        case FORMAT_BGRA8888 :
        case FORMAT_RGBA8888 :
            dx=x2-x1;           //Delta x
            dy=y2-y1;           //Delta y
            dxabs=abs(dx);      //Absolute delta
            dyabs=abs(dy);      //Absolute delta
            sdx=(dx>0)?1:-1; //signum function
            sdy=(dy>0)?1:-1; //signum function
            x=dyabs>>1;
            y=dxabs>>1;
            px=x1;
            py=y1;
 
            if (dxabs>=dyabs)
            {
                for(i=0;i<dxabs;i++)
                {
                    y+=dyabs;
                    if (y>=dxabs)
                    {
                        y-=dxabs;
                        py+=sdy;
                    }
                    px+=sdx;
                    drawPixel(pFrame, px, py, color);
                }
            }
            else
            {
                for(i=0;i<dyabs;i++)
                {
                    x+=dxabs;
                    if (x>=dyabs)
                    {
                        x-=dyabs;
                        px+=sdx;
                    }
                    py+=sdy;
                    drawPixel(pFrame, px, py, color);
                }
            }
            break;
 
        default :
            ERROR("Invalid param");
            break;
    }
}
 
/**
  * @brief  Draw a character to frame buffer
  * @param  pFrame: pointer to parameter of FrameBuffer structure
                 c :  character to draw
                 startx : start position of y axis for the character
                 starty : start position of x axis for the character
                 size : font size (This is not used. Fixed to 8x8)
                 color : color format(PixelFormat) of the character. 
  * @retval none
  */
void drawChar(FrameBuffer* pFrame, char c, uint32_t startx, uint32_t starty, uint32_t size, uint32_t color)
{
    unsigned x, y;
 
    if(pFrame == NULL) {
        ERROR("Invalid param");
        return;
    }
 
    switch(pFrame->format) {
        case FORMAT_BGR565 :
        case FORMAT_RGB565 :
        case FORMAT_BGR888 :
        case FORMAT_RGB888 :
        case FORMAT_ABGR8888 :
        case FORMAT_ARGB8888 :
        case FORMAT_BGRA8888 :
        case FORMAT_RGBA8888 :
            for (y = 0; y < 8; y++) {
                for (x = 0; x < 8; x++) {
                    bool b = get_char_pixel(c, x, y);
                    //if(b)
                        drawPixel(pFrame, startx + x, starty + y, b ? color : 0x00000000);
                }
            }
            break;
 
        default :
            ERROR("Invalid param");
            break;
    }
}
 
/**
  * @brief  Draw a string to frame buffer
  * @param  pFrame: pointer to parameter of FrameBuffer structure
                 str : pointer to parameter of string
                 startx : start position of y axis for the string
                 starty : start position of x axis for the string
                 size : font size (This is not used. Fixed to 8x8)
                 color : color format(PixelFormat) of the character. 
  * @retval none
  */
void drawString(FrameBuffer* pFrame, char* str, uint32_t startx, uint32_t starty, uint32_t size, uint32_t color)
{
    uint32_t i;
    uint32_t len;
    
    len = strlen(str);
 
    DBGLOG("[%s] startx:%d starty:%d, stride:%d, str_len : %d", __func__, startx, starty, pFrame->stride, len);
    DBGLOG("[%s] format:%d color:0x%08x", __func__, pFrame->format, color);
 
    if(pFrame == NULL) {
        ERROR("Invalid param");
        return;
    }
 
    for(i = 0; i < len; i++)
        drawChar(pFrame, str[i], (startx + 8 * i), starty, size, color);
}
 
----------------------------display-kms.h---------------------------------------

 
#ifndef DISPLAY_KMS_H_
#define DISPLAY_KMS_H_
 
#include <omap_drm.h>
#include <omap_drmif.h>
#define HAVE_CONFIG_H
 
#include "util.h"
 
struct plane {
    uint32_t id;
    uint32_t x;
    uint32_t y;
 
    uint32_t xres;
    uint32_t yres;
    uint32_t fb_id;
    uint32_t z_val;
    uint32_t glo_alp;
    uint32_t pre_mul_alp;
};
 
struct display {
    int fd;
    uint32_t width, height;
    struct omap_device *dev;
    struct list unlocked;
    struct rate_control rtctl;
 
    struct buffer ** (*get_buffers)(struct display *disp, uint32_t n);
    struct buffer ** (*get_vid_buffers)(struct display *disp,
            uint32_t n, uint32_t fourcc, uint32_t w, uint32_t h);
    int (*post_buffer)(struct display *disp, struct buffer *buf);
    int (*post_vid_buffer)(struct display *disp, struct buffer *buf,
            uint32_t x, uint32_t y, uint32_t w, uint32_t h);
    void (*close)(struct display *disp);
    void (*disp_free_buf) (struct display *disp, uint32_t n);
 
    bool multiplanar;   /* True when Y and U/V are in separate buffers. */
    struct buffer **buf;
 
    struct plane overlay_p;
    struct buffer *overlay_p_bo;
};
 
/* Print display related help */
void disp_usage(void);
 
/* Open display.. X11 or KMS depending on cmdline args, environment,
 * and build args
 */
struct display * disp_open(int argc, char **argv);
 
/* free allocated buffer */
void disp_free_buffers(struct display *disp, uint32_t n);
/* Close display */
static inline void
disp_close(struct display *disp)
{
    disp->close(disp);
}
 
/* Get normal RGB/UI buffers (ie. not scaled, not YUV) */
static inline struct buffer **
disp_get_buffers(struct display *disp, uint32_t n)
{
    return disp->get_buffers(disp, n);
}
 
/* Get video/overlay buffers (ie. can be YUV, scaled, etc) */
struct buffer ** disp_get_vid_buffers(struct display *disp, uint32_t n,
        uint32_t fourcc, uint32_t w, uint32_t h);
 
/* flip to / post the specified buffer */
int
disp_post_buffer(struct display *disp, struct buffer *buf);
 
/* flip to / post the specified video buffer */
int
disp_post_vid_buffer(struct display *disp, struct buffer *buf,
        uint32_t x, uint32_t y, uint32_t w, uint32_t h);
 
/* Get plane (id = 1) for every connector and update the overlay */
//int
//get_overlay_plane(struct display *disp, struct buffer *buf);
 
/* allocate a buffer from pool created by disp_get_vid_buffers() */
struct buffer * disp_get_vid_buffer(struct display *disp);
/* free to video buffer pool */
void disp_put_vid_buffer(struct display *disp, struct buffer *buf);
 
/* helper to setup the display for apps that just need video with
 * no flipchain on the GUI layer
 */
struct buffer * disp_get_fb(struct display *disp);
 
void fill(struct buffer *buf, int i);
 
struct buffer *alloc_buffer(struct display *disp, uint32_t fourcc, uint32_t w, uint32_t h, bool addfb);
 
void set_z_order(struct display *disp, uint32_t plane_id);
void set_global_alpha(struct display *disp, uint32_t plane_id);
void set_pre_multiplied_alpha(struct display *disp, uint32_t plane_id);
void alloc_overlay_plane(struct display *disp, uint32_t fourcc, int x, int y, int w, int h);
void free_overlay_plane(struct display *disp);
void update_overlay_disp(struct display *disp);
int get_framebuf(struct buffer *buf, unsigned char** ppfbuf);
 
#endif
---------------------------------------jpeg_utils.c----------------------------------------

 
#ifndef DISPLAY_KMS_H_
#define DISPLAY_KMS_H_
 
#include <omap_drm.h>
#include <omap_drmif.h>
#define HAVE_CONFIG_H
 
#include "util.h"
 
struct plane {
    uint32_t id;
    uint32_t x;
    uint32_t y;
 
    uint32_t xres;
    uint32_t yres;
    uint32_t fb_id;
    uint32_t z_val;
    uint32_t glo_alp;
    uint32_t pre_mul_alp;
};
 
struct display {
    int fd;
    uint32_t width, height;
    struct omap_device *dev;
    struct list unlocked;
    struct rate_control rtctl;
 
    struct buffer ** (*get_buffers)(struct display *disp, uint32_t n);
    struct buffer ** (*get_vid_buffers)(struct display *disp,
            uint32_t n, uint32_t fourcc, uint32_t w, uint32_t h);
    int (*post_buffer)(struct display *disp, struct buffer *buf);
    int (*post_vid_buffer)(struct display *disp, struct buffer *buf,
            uint32_t x, uint32_t y, uint32_t w, uint32_t h);
    void (*close)(struct display *disp);
    void (*disp_free_buf) (struct display *disp, uint32_t n);
 
    bool multiplanar;   /* True when Y and U/V are in separate buffers. */
    struct buffer **buf;
 
    struct plane overlay_p;
    struct buffer *overlay_p_bo;
};
 
/* Print display related help */
void disp_usage(void);
 
/* Open display.. X11 or KMS depending on cmdline args, environment,
 * and build args
 */
struct display * disp_open(int argc, char **argv);
 
/* free allocated buffer */
void disp_free_buffers(struct display *disp, uint32_t n);
/* Close display */
static inline void
disp_close(struct display *disp)
{
    disp->close(disp);
}
 
/* Get normal RGB/UI buffers (ie. not scaled, not YUV) */
static inline struct buffer **
disp_get_buffers(struct display *disp, uint32_t n)
{
    return disp->get_buffers(disp, n);
}
 
/* Get video/overlay buffers (ie. can be YUV, scaled, etc) */
struct buffer ** disp_get_vid_buffers(struct display *disp, uint32_t n,
        uint32_t fourcc, uint32_t w, uint32_t h);
 
/* flip to / post the specified buffer */
int
disp_post_buffer(struct display *disp, struct buffer *buf);
 
/* flip to / post the specified video buffer */
int
disp_post_vid_buffer(struct display *disp, struct buffer *buf,
        uint32_t x, uint32_t y, uint32_t w, uint32_t h);
 
/* Get plane (id = 1) for every connector and update the overlay */
//int
//get_overlay_plane(struct display *disp, struct buffer *buf);
 
/* allocate a buffer from pool created by disp_get_vid_buffers() */
struct buffer * disp_get_vid_buffer(struct display *disp);
/* free to video buffer pool */
void disp_put_vid_buffer(struct display *disp, struct buffer *buf);
 
/* helper to setup the display for apps that just need video with
 * no flipchain on the GUI layer
 */
struct buffer * disp_get_fb(struct display *disp);
 
void fill(struct buffer *buf, int i);
 
struct buffer *alloc_buffer(struct display *disp, uint32_t fourcc, uint32_t w, uint32_t h, bool addfb);
 
void set_z_order(struct display *disp, uint32_t plane_id);
void set_global_alpha(struct display *disp, uint32_t plane_id);
void set_pre_multiplied_alpha(struct display *disp, uint32_t plane_id);
void alloc_overlay_plane(struct display *disp, uint32_t fourcc, int x, int y, int w, int h);
void free_overlay_plane(struct display *disp);
void update_overlay_disp(struct display *disp);
int get_framebuf(struct buffer *buf, unsigned char** ppfbuf);
 
#endif
-----------------------------drawing.h----------------------------------

#ifndef DRAWING_H_
#define DRAWING_H_ 
 
#include <stdint.h>
 
typedef enum {
    FORMAT_BGR565,
    FORMAT_RGB565,
    FORMAT_BGR888,
    FORMAT_RGB888,
    FORMAT_ABGR8888,
    FORMAT_ARGB8888,
    FORMAT_BGRA8888,
    FORMAT_RGBA8888,
    // TODO .. add ohter foramt.. ex: yuyv, nv12, etc..
    
    FORMAT_MAX
} PixelFormat;
 
typedef struct _FrameBuffer
{
    PixelFormat format;
    uint32_t stride;
 
    unsigned char* buf;
} FrameBuffer;
 
PixelFormat draw_get_pixel_foramt(int fourcc);
void drawPixel(FrameBuffer* pFrame, uint32_t px, uint32_t py, uint32_t color);
void drawLine(FrameBuffer* pFrame, uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2, uint32_t color);
void drawChar(FrameBuffer* pFrame, char c, uint32_t startx, uint32_t starty, uint32_t size, uint32_t color);
void drawString(FrameBuffer* pFrame, char* str, uint32_t startx, uint32_t starty, uint32_t size, uint32_t color);
void drawRect(FrameBuffer* pFrame, uint32_t startx, uint32_t starty, uint32_t w, uint32_t h, uint32_t color);
 
#endif //DRAWING_H_
 
-----------------------jpeg_utils.h----------------------------------

#ifndef JPEG_UTILS_H_
#define JPEG_UTILS_H_ 
 
int compress_rgb24_to_jpeg(unsigned char* rgbbuf, int w, int h, int quality, char* filename);
 
#endif //JPEG_UTILS_H_
 
--------------------------input_cmd.h--------------------------------

#ifndef INPUT_CMD_H_
#define INPUT_CMD_H_ 
 
#ifdef __cplusplus
extern "C" {
#endif
 
extern char StandbyInput(char *inputbuf); 
 
#ifdef __cplusplus
}
#endif
 
#endif //INPUT_CMD_H_
 
--------------------------------config.h---------------------------------

/* config.h.  Generated from config.h.in by configure.  */
/* config.h.in.  Generated from configure.ac by autoheader.  */

/* Have DCE support */
//#define HAVE_DCE 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Have DOMX support */
/* #undef HAVE_DOMX */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Have KMSCUBE support */
//#define HAVE_KMSCUBE 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Have V4L2 DMABUF support */
#define HAVE_V4L2_DMABUF 1

/* Have WAYLAND support */
//#define HAVE_WAYLAND 1

/* Define to the sub-directory in which libtool stores uninstalled libraries.
   */
#define LT_OBJDIR ".libs/"

/* Name of package */
#define PACKAGE "omapdrmtest"

/* Define to the address where bug reports for this package should be sent. */
#define PACKAGE_BUGREPORT "https://www.ti.com"

/* Define to the full name of this package. */
#define PACKAGE_NAME "omapdrmtest"

/* Define to the full name and version of this package. */
#define PACKAGE_STRING "omapdrmtest 1.0.0"

/* Define to the one symbol short name of this package. */
#define PACKAGE_TARNAME "omapdrmtest"

/* Define to the home page for this package. */
#define PACKAGE_URL ""

/* Define to the version of this package. */
#define PACKAGE_VERSION "1.0.0"

/* Define to 1 if you have the ANSI C header files. */
#define STDC_HEADERS 1

/* Version number of package */
#define VERSION "1.0.0"
 





